<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GuoXin Li&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/liysky/liysky.github.io.git/"/>
  <updated>2021-01-14T12:02:25.756Z</updated>
  <id>https://github.com/liysky/liysky.github.io.git/</id>
  
  <author>
    <name>jax</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>full permutation with backtracking</title>
    <link href="https://github.com/liysky/liysky.github.io.git/2021/01/14/full-permutation-with-backtracking/"/>
    <id>https://github.com/liysky/liysky.github.io.git/2021/01/14/full-permutation-with-backtracking/</id>
    <published>2021-01-14T11:55:32.000Z</published>
    <updated>2021-01-14T12:02:25.756Z</updated>
    
    <content type="html"><![CDATA[<p>1, 2, 3 full permutation example in conventional “for circle” full permutation. </p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20210114195633990.png" alt="image-20210114195633990"></p><p>with vector path.</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20210114195922265.png" alt="image-20210114195922265"></p><p>then backtracking method.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> level, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;path )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(level == path.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:path)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;num&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(path[level] = <span class="number">1</span>; path[level] &lt;= path.<span class="built_in">size</span>(); path[level]++)&#123;</span><br><span class="line">        <span class="comment">// before enter into next layer decision tree,</span></span><br><span class="line">        <span class="comment">// checking whether path contains item contained or not.</span></span><br><span class="line">        <span class="comment">// std::count: Returns the number of elements in the range [first,last) that compare equal to val.</span></span><br><span class="line">        <span class="keyword">if</span>( count(path.<span class="built_in">begin</span>(), <span class="built_in">begin</span>(path) + level, path[level] ) != <span class="number">0</span> ) <span class="keyword">continue</span>;</span><br><span class="line">        fun(level+<span class="number">1</span>, path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">path</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    fun(<span class="number">0</span>, path);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reference: <a href="https://www.youtube.com/watch?v=nrHTtjkYEyQ" target="_blank" rel="noopener">https://www.youtube.com/watch?v=nrHTtjkYEyQ</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1, 2, 3 full permutation example in conventional “for circle” full permutation. &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://jaximage-1253102271.cos.ap-beij
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>高光谱分类-Hyperspectral Classification</title>
    <link href="https://github.com/liysky/liysky.github.io.git/2021/01/04/Hyperspectral-Classification/"/>
    <id>https://github.com/liysky/liysky.github.io.git/2021/01/04/Hyperspectral-Classification/</id>
    <published>2021-01-03T16:47:43.000Z</published>
    <updated>2021-01-05T08:04:43.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HybridSN"><a href="#HybridSN" class="headerlink" title="HybridSN"></a>HybridSN</h1><p><strong>阅读论文：</strong></p><p><a href="https://arxiv.org/abs/1902.06701" target="_blank" rel="noopener"><strong>HybridSN: Exploring 3D-2D CNN Feature Hierarchy for Hyperspectral Image Classification</strong></a></p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p><strong>高光谱图像 hyperspectral image：</strong></p><p>高光谱遥感指具有高光谱分辨率的遥感数据获取、处理、分析和应用的科学与技术，通常采用覆盖一定波谱范围的成像光谱仪和非成像光谱仪两种传感器获取数据，利用大量窄波段电磁波获取感兴趣目标的理化信息，其基础是光谱学(Spectroscopy)</p><p><strong>高光谱图像分类:</strong></p><p>分类是高光谱遥感影像处理和应用的一项重要内容，其最终目标是给影像中的每个像元赋以唯一的类别标识。然而，高光谱遥感影像的高维特性、波段间高度相关性、光谱混合等使得高光谱遥感影像分类面临巨大挑战.</p><p><strong>作者提出 Hybrid-CNN模型的原因</strong></p><ul><li>单纯的2D-CNN并不能从光谱维度中提取出良好的判别特征图。</li><li>同样，深层的3D-CNN在计算上更加复杂，单独的3D-CNN对于在许多光谱波段上具有相似纹理的类似乎表现更差。</li><li>利用3D和2D混合能够充分地利用光谱特征和空间特征来提高分类精度。</li></ul><h2 id="获取数据，并引入基本函数库"><a href="#获取数据，并引入基本函数库" class="headerlink" title="获取数据，并引入基本函数库"></a>获取数据，并引入基本函数库</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">! wget http://www.ehu.eus/ccwintco/uploads/<span class="number">6</span>/<span class="number">67</span>/Indian_pines_corrected.mat</span><br><span class="line">! wget http://www.ehu.eus/ccwintco/uploads/c/c4/Indian_pines_gt.mat</span><br><span class="line">! pip install spectral</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> scipy.io <span class="keyword">as</span> sio</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix, accuracy_score, classification_report, cohen_kappa_score</span><br><span class="line"><span class="keyword">import</span> spectral</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br></pre></td></tr></table></figure><h2 id="定义-hybridSN类"><a href="#定义-hybridSN类" class="headerlink" title="定义 hybridSN类"></a>定义 hybridSN类</h2><p>模型的网络结构如下：</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/Screen%20Shot%202020-12-31%20at%2016.53.52.png" alt="Screen Shot 2020-12-31 at 16.53.52"></p><p><strong>三维卷积部分</strong></p><ul><li>conv1：（1, 30, 25, 25）， 8个 7x3x3 的卷积核 ==&gt;（8, 24, 23, 23）</li><li>conv2：（8, 24, 23, 23）， 16个 5x3x3 的卷积核 ==&gt;（16, 20, 21, 21）</li><li>conv3：（16, 20, 21, 21），32个 3x3x3 的卷积核 ==&gt;（32, 18, 19, 19）</li></ul><p><strong>二维卷积</strong></p><p>将前面的 32*18 reshape 得到 （576，19，19）</p><ul><li><p>（576, 19, 19） 64个 3x3 的卷积核，==&gt; （64, 17, 17）</p></li><li><p>flatten 操作，变为 18496 维的向量</p></li><li>使用 256，128 的全连接层，都是用0.4的 Dropout</li><li>最后输出为 16 个节点，是最终的分类类别数</li></ul><p><strong>HybridSN 类</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class_num = <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HybridSN</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    super(HybridSN,self).__init__()</span><br><span class="line"><span class="comment"># 3D</span></span><br><span class="line">    self.conv3d_1=nn.Sequential(</span><br><span class="line">        nn.Conv3d(<span class="number">1</span>,<span class="number">8</span>,kernel_size=(<span class="number">7</span>, <span class="number">3</span>, <span class="number">3</span>),stride=<span class="number">1</span>, padding=<span class="number">0</span>),</span><br><span class="line">        nn.BatchNorm3d(<span class="number">8</span>),</span><br><span class="line">        nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">    )</span><br><span class="line">    self.conv3d_2 = nn.Sequential(</span><br><span class="line">        nn.Conv3d(<span class="number">8</span>, <span class="number">16</span>, kernel_size=(<span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>), stride=<span class="number">1</span>, padding=<span class="number">0</span>),</span><br><span class="line">        nn.BatchNorm3d(<span class="number">16</span>),</span><br><span class="line">        nn.ReLU(inplace = <span class="literal">True</span>),</span><br><span class="line">    ) </span><br><span class="line">    self.conv3d_3 = nn.Sequential(</span><br><span class="line">        nn.Conv3d(<span class="number">16</span>, <span class="number">32</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>), stride=<span class="number">1</span>, padding=<span class="number">0</span>),</span><br><span class="line">        nn.BatchNorm3d(<span class="number">32</span>),</span><br><span class="line">        nn.ReLU(inplace = <span class="literal">True</span>)</span><br><span class="line">    )</span><br><span class="line"><span class="comment"># 2D </span></span><br><span class="line">    self.conv2d = nn.Sequential(</span><br><span class="line">        nn.Conv2d(<span class="number">576</span>, <span class="number">64</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), stride=<span class="number">1</span>, padding=<span class="number">0</span>),</span><br><span class="line">        nn.BatchNorm2d(<span class="number">64</span>),</span><br><span class="line">        nn.ReLU(inplace = <span class="literal">True</span>),</span><br><span class="line">    )</span><br><span class="line">    self.fc1 = nn.Linear(<span class="number">18496</span>,<span class="number">256</span>)</span><br><span class="line">    self.fc2 = nn.Linear(<span class="number">256</span>,<span class="number">128</span>)</span><br><span class="line">    self.fc3 = nn.Linear(<span class="number">128</span>,<span class="number">16</span>)</span><br><span class="line">    self.dropout = nn.Dropout(p = <span class="number">0.4</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">    out = self.conv3d_1(x)</span><br><span class="line">    out = self.conv3d_2(out)</span><br><span class="line">    out = self.conv3d_3(out)</span><br><span class="line">    out = self.conv2d(out.reshape(out.shape[<span class="number">0</span>],<span class="number">-1</span>,<span class="number">19</span>,<span class="number">19</span>))</span><br><span class="line">    out = out.reshape(out.shape[<span class="number">0</span>],<span class="number">-1</span>)</span><br><span class="line">    out = F.relu(self.dropout(self.fc1(out)))</span><br><span class="line">    out = F.relu(self.dropout(self.fc2(out)))</span><br><span class="line">    out = self.fc3(out)</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 随机输入，测试网络结构是否通</span></span><br><span class="line"><span class="comment"># x = torch.randn(1, 1, 30, 25, 25)</span></span><br><span class="line"><span class="comment"># net = HybridSN()</span></span><br><span class="line"><span class="comment"># y = net(x)</span></span><br><span class="line"><span class="comment"># print(y.shape)</span></span><br></pre></td></tr></table></figure><h2 id="创建数据集"><a href="#创建数据集" class="headerlink" title="创建数据集"></a>创建数据集</h2><p>首先对高光谱数据实施PCA降维；然后创建 keras 方便处理的数据格式；然后随机抽取 10% 数据做为训练集，剩余的做为测试集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 对高光谱数据 X 应用 PCA 变换</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">applyPCA</span><span class="params">(X, numComponents)</span>:</span></span><br><span class="line">    newX = np.reshape(X, (<span class="number">-1</span>, X.shape[<span class="number">2</span>]))</span><br><span class="line">    pca = PCA(n_components=numComponents, whiten=<span class="literal">True</span>)</span><br><span class="line">    newX = pca.fit_transform(newX)</span><br><span class="line">    newX = np.reshape(newX, (X.shape[<span class="number">0</span>], X.shape[<span class="number">1</span>], numComponents))</span><br><span class="line">    <span class="keyword">return</span> newX</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对单个像素周围提取 patch 时，边缘像素就无法取了，因此，给这部分像素进行 padding 操作</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">padWithZeros</span><span class="params">(X, margin=<span class="number">2</span>)</span>:</span></span><br><span class="line">    newX = np.zeros((X.shape[<span class="number">0</span>] + <span class="number">2</span> * margin, X.shape[<span class="number">1</span>] + <span class="number">2</span>* margin, X.shape[<span class="number">2</span>]))</span><br><span class="line">    x_offset = margin</span><br><span class="line">    y_offset = margin</span><br><span class="line">    newX[x_offset:X.shape[<span class="number">0</span>] + x_offset, y_offset:X.shape[<span class="number">1</span>] + y_offset, :] = X</span><br><span class="line">    <span class="keyword">return</span> newX</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在每个像素周围提取 patch ，然后创建成符合 keras 处理的格式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createImageCubes</span><span class="params">(X, y, windowSize=<span class="number">5</span>, removeZeroLabels = True)</span>:</span></span><br><span class="line">    <span class="comment"># 给 X 做 padding</span></span><br><span class="line">    margin = int((windowSize - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">    zeroPaddedX = padWithZeros(X, margin=margin)</span><br><span class="line">    <span class="comment"># split patches</span></span><br><span class="line">    patchesData = np.zeros((X.shape[<span class="number">0</span>] * X.shape[<span class="number">1</span>], windowSize, windowSize, X.shape[<span class="number">2</span>]))</span><br><span class="line">    patchesLabels = np.zeros((X.shape[<span class="number">0</span>] * X.shape[<span class="number">1</span>]))</span><br><span class="line">    patchIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> range(margin, zeroPaddedX.shape[<span class="number">0</span>] - margin):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(margin, zeroPaddedX.shape[<span class="number">1</span>] - margin):</span><br><span class="line">            patch = zeroPaddedX[r - margin:r + margin + <span class="number">1</span>, c - margin:c + margin + <span class="number">1</span>]   </span><br><span class="line">            patchesData[patchIndex, :, :, :] = patch</span><br><span class="line">            patchesLabels[patchIndex] = y[r-margin, c-margin]</span><br><span class="line">            patchIndex = patchIndex + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> removeZeroLabels:</span><br><span class="line">        patchesData = patchesData[patchesLabels&gt;<span class="number">0</span>,:,:,:]</span><br><span class="line">        patchesLabels = patchesLabels[patchesLabels&gt;<span class="number">0</span>]</span><br><span class="line">        patchesLabels -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> patchesData, patchesLabels</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitTrainTestSet</span><span class="params">(X, y, testRatio, randomState=<span class="number">345</span>)</span>:</span></span><br><span class="line">    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=testRatio, random_state=randomState, stratify=y)</span><br><span class="line">    <span class="keyword">return</span> X_train, X_test, y_train, y_test</span><br></pre></td></tr></table></figure><p>读取并创建数据集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 地物类别</span></span><br><span class="line">class_num = <span class="number">16</span></span><br><span class="line">X = sio.loadmat(<span class="string">'Indian_pines_corrected.mat'</span>)[<span class="string">'indian_pines_corrected'</span>]</span><br><span class="line">y = sio.loadmat(<span class="string">'Indian_pines_gt.mat'</span>)[<span class="string">'indian_pines_gt'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于测试样本的比例</span></span><br><span class="line">test_ratio = <span class="number">0.90</span></span><br><span class="line"><span class="comment"># 每个像素周围提取 patch 的尺寸</span></span><br><span class="line">patch_size = <span class="number">25</span></span><br><span class="line"><span class="comment"># 使用 PCA 降维，得到主成分的数量</span></span><br><span class="line">pca_components = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'Hyperspectral data shape: '</span>, X.shape)</span><br><span class="line">print(<span class="string">'Label shape: '</span>, y.shape)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'\n... ... PCA tranformation ... ...'</span>)</span><br><span class="line">X_pca = applyPCA(X, numComponents=pca_components)</span><br><span class="line">print(<span class="string">'Data shape after PCA: '</span>, X_pca.shape)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'\n... ... create data cubes ... ...'</span>)</span><br><span class="line">X_pca, y = createImageCubes(X_pca, y, windowSize=patch_size)</span><br><span class="line">print(<span class="string">'Data cube X shape: '</span>, X_pca.shape)</span><br><span class="line">print(<span class="string">'Data cube y shape: '</span>, y.shape)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'\n... ... create train &amp; test data ... ...'</span>)</span><br><span class="line">Xtrain, Xtest, ytrain, ytest = splitTrainTestSet(X_pca, y, test_ratio)</span><br><span class="line">print(<span class="string">'Xtrain shape: '</span>, Xtrain.shape)</span><br><span class="line">print(<span class="string">'Xtest  shape: '</span>, Xtest.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改变 Xtrain, Ytrain 的形状，以符合 keras 的要求</span></span><br><span class="line">Xtrain = Xtrain.reshape(<span class="number">-1</span>, patch_size, patch_size, pca_components, <span class="number">1</span>)</span><br><span class="line">Xtest  = Xtest.reshape(<span class="number">-1</span>, patch_size, patch_size, pca_components, <span class="number">1</span>)</span><br><span class="line">print(<span class="string">'before transpose: Xtrain shape: '</span>, Xtrain.shape) </span><br><span class="line">print(<span class="string">'before transpose: Xtest  shape: '</span>, Xtest.shape) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了适应 pytorch 结构，数据要做 transpose</span></span><br><span class="line">Xtrain = Xtrain.transpose(<span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">Xtest  = Xtest.transpose(<span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">print(<span class="string">'after transpose: Xtrain shape: '</span>, Xtrain.shape) </span><br><span class="line">print(<span class="string">'after transpose: Xtest  shape: '</span>, Xtest.shape) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">""" Training dataset"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrainDS</span><span class="params">(torch.utils.data.Dataset)</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.len = Xtrain.shape[<span class="number">0</span>]</span><br><span class="line">        self.x_data = torch.FloatTensor(Xtrain)</span><br><span class="line">        self.y_data = torch.LongTensor(ytrain)        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="comment"># 根据索引返回数据和对应的标签</span></span><br><span class="line">        <span class="keyword">return</span> self.x_data[index], self.y_data[index]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span> </span><br><span class="line">        <span class="comment"># 返回文件数据的数目</span></span><br><span class="line">        <span class="keyword">return</span> self.len</span><br><span class="line"></span><br><span class="line"><span class="string">""" Testing dataset"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDS</span><span class="params">(torch.utils.data.Dataset)</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.len = Xtest.shape[<span class="number">0</span>]</span><br><span class="line">        self.x_data = torch.FloatTensor(Xtest)</span><br><span class="line">        self.y_data = torch.LongTensor(ytest)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="comment"># 根据索引返回数据和对应的标签</span></span><br><span class="line">        <span class="keyword">return</span> self.x_data[index], self.y_data[index]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span> </span><br><span class="line">        <span class="comment"># 返回文件数据的数目</span></span><br><span class="line">        <span class="keyword">return</span> self.len</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 trainloader 和 testloader</span></span><br><span class="line">trainset = TrainDS()</span><br><span class="line">testset  = TestDS()</span><br><span class="line">train_loader = torch.utils.data.DataLoader(dataset=trainset, batch_size=<span class="number">128</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">2</span>)</span><br><span class="line">test_loader  = torch.utils.data.DataLoader(dataset=testset,  batch_size=<span class="number">128</span>, shuffle=<span class="literal">False</span>, num_workers=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>out：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Hyperspectral data shape:  (145, 145, 200)</span><br><span class="line">Label shape:  (145, 145)</span><br><span class="line"></span><br><span class="line">... ... PCA tranformation ... ...</span><br><span class="line">Data shape after PCA:  (145, 145, 30)</span><br><span class="line"></span><br><span class="line">... ... create data cubes ... ...</span><br><span class="line">Data cube X shape:  (10249, 25, 25, 30)</span><br><span class="line">Data cube y shape:  (10249,)</span><br><span class="line"></span><br><span class="line">... ... create train &amp; test data ... ...</span><br><span class="line">Xtrain shape:  (1024, 25, 25, 30)</span><br><span class="line">Xtest  shape:  (9225, 25, 25, 30)</span><br><span class="line">before transpose: Xtrain shape:  (1024, 25, 25, 30, 1)</span><br><span class="line">before transpose: Xtest  shape:  (9225, 25, 25, 30, 1)</span><br><span class="line">after transpose: Xtrain shape:  (1024, 1, 30, 25, 25)</span><br><span class="line">after transpose: Xtest  shape:  (9225, 1, 30, 25, 25)</span><br></pre></td></tr></table></figure><h2 id="开始训练"><a href="#开始训练" class="headerlink" title="开始训练"></a>开始训练</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用GPU训练，可以在菜单 "代码执行工具" -&gt; "更改运行时类型" 里进行设置</span></span><br><span class="line">device = torch.device(<span class="string">"cuda:0"</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 网络放到GPU上</span></span><br><span class="line">net = HybridSN().to(device)</span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.Adam(net.parameters(), lr=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始训练</span></span><br><span class="line">total_loss = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">for</span> i, (inputs, labels) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">        inputs = inputs.to(device)</span><br><span class="line">        labels = labels.to(device)</span><br><span class="line">        <span class="comment"># 优化器梯度归零</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        <span class="comment"># 正向传播 +　反向传播 + 优化 </span></span><br><span class="line">        outputs = net(inputs)</span><br><span class="line">        loss = criterion(outputs, labels)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        total_loss += loss.item()</span><br><span class="line">    print(<span class="string">'[Epoch: %d]   [loss avg: %.4f]   [current loss: %.4f]'</span> %(epoch + <span class="number">1</span>, total_loss/(epoch+<span class="number">1</span>), loss.item()))</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Finished Training'</span>)</span><br></pre></td></tr></table></figure><p>out:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[Epoch: 1]   [loss avg: 20.8664]   [current loss: 2.5130]</span><br><span class="line">[Epoch: 2]   [loss avg: 20.1485]   [current loss: 2.3768]</span><br><span class="line">[Epoch: 3]   [loss avg: 19.5493]   [current loss: 2.2176]</span><br><span class="line">[Epoch: 4]   [loss avg: 18.9607]   [current loss: 2.0665]</span><br><span class="line">[Epoch: 5]   [loss avg: 18.4340]   [current loss: 1.9149]</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[Epoch: 70]   [loss avg: 2.4159]   [current loss: 0.0473]</span><br><span class="line">[Epoch: 71]   [loss avg: 2.3844]   [current loss: 0.0155]</span><br><span class="line">[Epoch: 72]   [loss avg: 2.3523]   [current loss: 0.0012]</span><br><span class="line">[Epoch: 73]   [loss avg: 2.3204]   [current loss: 0.0043]</span><br><span class="line">[Epoch: 74]   [loss avg: 2.2897]   [current loss: 0.0007]</span><br><span class="line">[Epoch: 75]   [loss avg: 2.2593]   [current loss: 0.0004]</span><br><span class="line">...</span><br><span class="line">[Epoch: 95]   [loss avg: 1.8108]   [current loss: 0.0410]</span><br><span class="line">[Epoch: 96]   [loss avg: 1.7933]   [current loss: 0.0426]</span><br><span class="line">[Epoch: 97]   [loss avg: 1.7755]   [current loss: 0.0059]</span><br><span class="line">[Epoch: 98]   [loss avg: 1.7581]   [current loss: 0.0113]</span><br><span class="line">[Epoch: 99]   [loss avg: 1.7415]   [current loss: 0.0016]</span><br><span class="line">[Epoch: 100]   [loss avg: 1.7261]   [current loss: 0.0187]</span><br><span class="line">Finished Training</span><br></pre></td></tr></table></figure><h2 id="模型测试"><a href="#模型测试" class="headerlink" title="模型测试"></a>模型测试</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="comment"># 模型测试</span></span><br><span class="line"><span class="keyword">for</span> inputs, _ <span class="keyword">in</span> test_loader:</span><br><span class="line">    inputs = inputs.to(device)</span><br><span class="line">    outputs = net(inputs)</span><br><span class="line">    outputs = np.argmax(outputs.detach().cpu().numpy(), axis=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">        y_pred_test =  outputs</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        y_pred_test = np.concatenate( (y_pred_test, outputs) )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成分类报告</span></span><br><span class="line">classification = classification_report(ytest, y_pred_test, digits=<span class="number">4</span>)</span><br><span class="line">print(classification)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">              precision    recall  f1-score   support</span><br><span class="line"></span><br><span class="line">         0.0     0.9487    0.9024    0.9250        41</span><br><span class="line">         1.0     0.9540    0.9518    0.9529      1285</span><br><span class="line">         2.0     0.9495    0.9572    0.9533       747</span><br><span class="line">         3.0     1.0000    0.8028    0.8906       213</span><br><span class="line">         4.0     0.8747    0.9954    0.9312       435</span><br><span class="line">         5.0     0.9847    0.9787    0.9817       657</span><br><span class="line">         6.0     1.0000    0.9200    0.9583        25</span><br><span class="line">         7.0     0.9534    1.0000    0.9762       430</span><br><span class="line">         8.0     0.8571    0.6667    0.7500        18</span><br><span class="line">         9.0     0.9939    0.9371    0.9647       875</span><br><span class="line">        10.0     0.9695    0.9941    0.9817      2210</span><br><span class="line">        11.0     0.9393    0.9270    0.9331       534</span><br><span class="line">        12.0     0.9432    0.8973    0.9197       185</span><br><span class="line">        13.0     0.9806    0.9781    0.9793      1139</span><br><span class="line">        14.0     0.9647    0.9452    0.9549       347</span><br><span class="line">        15.0     0.9459    0.8333    0.8861        84</span><br><span class="line"></span><br><span class="line">    accuracy                         0.9623      9225</span><br><span class="line">   macro avg     0.9537    0.9179    0.9337      9225</span><br><span class="line">weighted avg     0.9631    0.9623    0.9620      9225</span><br></pre></td></tr></table></figure><h2 id="显示分类结果"><a href="#显示分类结果" class="headerlink" title="显示分类结果"></a>显示分类结果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#显示分类结果</span></span><br><span class="line"><span class="comment"># load the original image</span></span><br><span class="line">X = sio.loadmat(<span class="string">'Indian_pines_corrected.mat'</span>)[<span class="string">'indian_pines_corrected'</span>]</span><br><span class="line">y = sio.loadmat(<span class="string">'Indian_pines_gt.mat'</span>)[<span class="string">'indian_pines_gt'</span>]</span><br><span class="line"></span><br><span class="line">height = y.shape[<span class="number">0</span>]</span><br><span class="line">width = y.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">X = applyPCA(X, numComponents= pca_components)</span><br><span class="line">X = padWithZeros(X, patch_size//<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 逐像素预测类别</span></span><br><span class="line">outputs = np.zeros((height,width))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(height):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(width):</span><br><span class="line">        <span class="keyword">if</span> int(y[i,j]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            image_patch = X[i:i+patch_size, j:j+patch_size, :]</span><br><span class="line">            image_patch = image_patch.reshape(<span class="number">1</span>,image_patch.shape[<span class="number">0</span>],image_patch.shape[<span class="number">1</span>], image_patch.shape[<span class="number">2</span>], <span class="number">1</span>)</span><br><span class="line">            X_test_image = torch.FloatTensor(image_patch.transpose(<span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>)).to(device)                                   </span><br><span class="line">            prediction = net(X_test_image)</span><br><span class="line">            prediction = np.argmax(prediction.detach().cpu().numpy(), axis=<span class="number">1</span>)</span><br><span class="line">            outputs[i][j] = prediction+<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">20</span> == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">'... ... row '</span>, i, <span class="string">' handling ... ...'</span>)</span><br><span class="line"></span><br><span class="line">predict_image = spectral.imshow(classes = outputs.astype(int),figsize =(<span class="number">5</span>,<span class="number">5</span>))</span><br></pre></td></tr></table></figure><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20210104131557618.png" alt="image-20210104131557618"></p><h2 id="加入注意力机制"><a href="#加入注意力机制" class="headerlink" title="加入注意力机制"></a><strong>加入注意力机制</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通道注意力机制</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChannelAttention</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, in_planes, ratio=<span class="number">16</span>)</span>:</span></span><br><span class="line">        super(ChannelAttention, self).__init__()</span><br><span class="line">        self.avg_pool = nn.AdaptiveAvgPool2d(<span class="number">1</span>)</span><br><span class="line">        self.max_pool = nn.AdaptiveMaxPool2d(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">        self.fc1   = nn.Conv2d(in_planes, in_planes // <span class="number">16</span>, <span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        self.relu1 = nn.ReLU()</span><br><span class="line">        self.fc2   = nn.Conv2d(in_planes // <span class="number">16</span>, in_planes, <span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line"> </span><br><span class="line">        self.sigmoid = nn.Sigmoid()</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        avg_out = self.fc2(self.relu1(self.fc1(self.avg_pool(x))))</span><br><span class="line">        max_out = self.fc2(self.relu1(self.fc1(self.max_pool(x))))</span><br><span class="line">        out = avg_out + max_out</span><br><span class="line">        <span class="keyword">return</span> self.sigmoid(out)</span><br><span class="line"><span class="comment"># 空间注意力机制</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpatialAttention</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, kernel_size=<span class="number">7</span>)</span>:</span></span><br><span class="line">        super(SpatialAttention, self).__init__()</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">assert</span> kernel_size <span class="keyword">in</span> (<span class="number">3</span>, <span class="number">7</span>), <span class="string">'kernel size must be 3 or 7'</span></span><br><span class="line">        padding = <span class="number">3</span> <span class="keyword">if</span> kernel_size == <span class="number">7</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">2</span>, <span class="number">1</span>, kernel_size, padding=padding, bias=<span class="literal">False</span>)</span><br><span class="line">        self.sigmoid = nn.Sigmoid()</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        avg_out = torch.mean(x, dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">        max_out, _ = torch.max(x, dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">        x = torch.cat([avg_out, max_out], dim=<span class="number">1</span>)</span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        <span class="keyword">return</span> self.sigmoid(x)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HybridSN</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_classes=<span class="number">16</span>, self_attention=True)</span>:</span></span><br><span class="line">  super(HybridSN, self).__init__()</span><br><span class="line">  self.self_attention = self_attention</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 3D</span></span><br><span class="line">  self.block_1_3D = nn.Sequential(</span><br><span class="line">    nn.Conv3d(</span><br><span class="line">      in_channels=<span class="number">1</span>,</span><br><span class="line">      out_channels=<span class="number">8</span>,</span><br><span class="line">      kernel_size=(<span class="number">7</span>, <span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">      stride=<span class="number">1</span>,</span><br><span class="line">      padding=<span class="number">0</span></span><br><span class="line">    ),</span><br><span class="line">    nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">    nn.Conv3d(</span><br><span class="line">      in_channels=<span class="number">8</span>,</span><br><span class="line">      out_channels=<span class="number">16</span>,</span><br><span class="line">      kernel_size=(<span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">      stride=<span class="number">1</span>,</span><br><span class="line">      padding=<span class="number">0</span></span><br><span class="line">    ),</span><br><span class="line">    nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">    nn.Conv3d(</span><br><span class="line">      in_channels=<span class="number">16</span>,</span><br><span class="line">      out_channels=<span class="number">32</span>,</span><br><span class="line">      kernel_size=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">      stride=<span class="number">1</span>,</span><br><span class="line">      padding=<span class="number">0</span></span><br><span class="line">    ),</span><br><span class="line">    nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> self_attention:</span><br><span class="line">    self.channel_attention_1 = ChannelAttention(<span class="number">576</span>)</span><br><span class="line">    self.spatial_attention_1 = SpatialAttention(kernel_size=<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2D</span></span><br><span class="line">    self.block_2_2D = nn.Sequential(</span><br><span class="line">      nn.Conv2d(</span><br><span class="line">        in_channels=<span class="number">576</span>,</span><br><span class="line">        out_channels=<span class="number">64</span>,</span><br><span class="line">        kernel_size=(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">      ),</span><br><span class="line">      nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self_attention:</span><br><span class="line">      self.channel_attention_2 = ChannelAttention(<span class="number">64</span>)</span><br><span class="line">      self.spatial_attention_2 = SpatialAttention(kernel_size=<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># full connect</span></span><br><span class="line">      self.classifier = nn.Sequential(</span><br><span class="line">        nn.Linear(</span><br><span class="line">          in_features=<span class="number">18496</span>,</span><br><span class="line">          out_features=<span class="number">256</span></span><br><span class="line">        ),</span><br><span class="line">        nn.Dropout(p=<span class="number">0.4</span>),</span><br><span class="line">        nn.Linear(</span><br><span class="line">          in_features=<span class="number">256</span>,</span><br><span class="line">          out_features=<span class="number">128</span></span><br><span class="line">        ),</span><br><span class="line">        nn.Dropout(p=<span class="number">0.4</span>),</span><br><span class="line">        nn.Linear(</span><br><span class="line">          in_features=<span class="number">128</span>,</span><br><span class="line">          out_features=num_classes</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">  y = self.block_1_3D(x)</span><br><span class="line">  y = y.view(<span class="number">-1</span>, y.shape[<span class="number">1</span>] * y.shape[<span class="number">2</span>], y.shape[<span class="number">3</span>], y.shape[<span class="number">4</span>])</span><br><span class="line">  <span class="keyword">if</span> self.self_attention:</span><br><span class="line">    y = self.channel_attention_1(y) * y</span><br><span class="line">    y = self.spatial_attention_1(y) * y</span><br><span class="line">    y = self.block_2_2D(y)</span><br><span class="line">    <span class="keyword">if</span> self.self_attention:</span><br><span class="line">      y = self.channel_attention_2(y) * y</span><br><span class="line">      y = self.spatial_attention_2(y) * y</span><br><span class="line"></span><br><span class="line">      y = y.view(y.size(<span class="number">0</span>), <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">      y = self.classifier(y)</span><br><span class="line">      <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/Screen%20Shot%202021-01-01%20at%2000.29.32.png" alt="Screen Shot at 00.29.32"></p><p><strong>模型检测</strong></p><div class="table-container"><table><thead><tr><th>测试次数</th><th>测试结果</th></tr></thead><tbody><tr><td>测试1</td><td><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/Screen%20Shot%202021-01-03%20at%2017.12.28-20210103171503072.png" alt="Screen Shot 2021-01-03 at 17.12.28"></td></tr><tr><td>测试2</td><td><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20210103171324381-20210103171458133.png" alt="image-20210103171324381"></td></tr><tr><td>测试3</td><td><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/Screen%20Shot%202021-01-03%20at%2017.13.46.png" alt="Screen Shot 2021-01-03 at 17.13.46"></td></tr></tbody></table></div><h2 id="思考题🤔"><a href="#思考题🤔" class="headerlink" title="思考题🤔"></a>思考题🤔</h2><p><strong>一：3D卷机与2D卷积的区别</strong></p><ul><li>卷积的方向和输出的形状很重要</li></ul><div class="table-container"><table><thead><tr><th>一维卷积</th><th>二维卷积</th><th>三维卷积</th></tr></thead><tbody><tr><td><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/Screen%20Shot%202021-01-03%20at%2015.29.45.png" alt="Screen Shot 2021-01-03 at 15.29.45"></td><td><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20210103153053452.png" alt="image-20210103153053452"></td><td><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20210103153105101.png" alt="image-20210103153105101"></td></tr></tbody></table></div><ul><li>卷积核的区别：2D 3D</li></ul><div class="table-container"><table><thead><tr><th>二维卷积</th><th>三维卷积</th></tr></thead><tbody><tr><td><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/v2-8a6695c2e086525ac5a61610348739b2_b.webp.gif" alt="v2-8a6695c2e086525ac5a61610348739b2_b.webp"></td><td><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/v2-86e2bd970d07f9d6e1d921b248e45a3a_b.webp.gif" alt="v2-86e2bd970d07f9d6e1d921b248e45a3a_b.webp"></td></tr></tbody></table></div><ul><li>3D 卷积多了一个深度的通道，但是这跟单纯的2D卷积的多通道卷积区别在于，3D卷积由于卷积核本身就是3D的，所以权重共享。</li><li>3D卷积多了一个深度通道，找个深度可能是视频上的连续帧，也可能是立体图像中的不同切片。</li></ul><p><strong>二：训练网络，然后多测试几次，会发现每次分类的结果都不一样，请思考为什么？</strong></p><p>这是因为在训练model之后再进行测试样本时，需要在 model 之前加上 model.eval() 这个函数调用。否则即使不训练，也会去改变权值，这是 model 中含有的 batch normalization 即 BN 所导致的。</p><p>在模型检测 model.eval() 后，Pytorch 会自动把 BN 和 Dropout 固定住，不会取平均，而是用训练好的值，一旦测试的的batch_size过小，很容易就会被BN层影响结果。</p><p>所以需要对源代码的训练和测试分别加上 model.train() 和 model.eval()来区分开来，这样多次测试的结果就一致了。</p><p><strong>三：如果想要进一步提升高光谱图像的分类性能，可以如何使用注意力机制？</strong></p><p>我们可以粗略地把神经注意机制类比成一个可以专注于输入内容的某一子集（或特征）的神经网络. 注意力机制最早是由 DeepMind 为图像分类提出的，这让「神经网络在执行预测任务时可以更多关注输入中的相关部分，更少关注不相关的部分」。</p><p>注意力机制像人眼观察事物的模式，使网络更加有侧重的学习，以此提高网络的学习能力。</p><p>可以通过构建不同的注意力模块（通道注意力模块、光谱注意力模块、空间注意力模块）然后将其并入到原有的卷积网络中，所构建的注意力子网络模块能够分别关注到通道、光谱域和空间域中更多的信息。</p><ul><li>通道注意力机制(Channel Attention，CA)是对同一个特征图的不同通道进行选择 优化，获取重校订的通道信息;</li><li>空间注意力机制(Spatial Attention，SA)则是对同一个特征图的所有空间位置重新分配权重，然后通过 Sigmoid 函数来激活得到非线性的重校订上下文信息。</li></ul><p>参考：</p><ul><li>程文娟，陈文强 . 基于 MCFFN-Attention 的高光谱图像分类 . 计算机工程与应用，2020，56(24):201-206. CHENG Wenjuan, CHEN Wenqiang. Hyperspectral image classification based on MCFFN-Attention. Computer Engineering and Applications, 2020, 56(24):201-206.</li><li><a href="https://www.jiqizhixin.com/graph/technologies/60bee267-89dc-4606-ba24-6b3f7d1f6189" target="_blank" rel="noopener">机器之心注意力机制</a></li><li><a href="https://stackoverflow.com/questions/42883547/intuitive-understanding-of-1d-2d-and-3d-convolutions-in-convolutional-neural-n" target="_blank" rel="noopener">https://stackoverflow.com/questions/42883547/intuitive-understanding-of-1d-2d-and-3d-convolutions-in-convolutional-neural-n</a></li><li><a href="https://zhuanlan.zhihu.com/p/53036028" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/53036028</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HybridSN&quot;&gt;&lt;a href=&quot;#HybridSN&quot; class=&quot;headerlink&quot; title=&quot;HybridSN&quot;&gt;&lt;/a&gt;HybridSN&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;阅读论文：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https:/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>LeetCode 322. Coin Change</title>
    <link href="https://github.com/liysky/liysky.github.io.git/2020/12/06/LeetCode-322-Coin-Change/"/>
    <id>https://github.com/liysky/liysky.github.io.git/2020/12/06/LeetCode-322-Coin-Change/</id>
    <published>2020-12-05T16:07:17.000Z</published>
    <updated>2020-12-05T16:10:19.938Z</updated>
    
    <content type="html"><![CDATA[<h1 id="322-Coin-Change"><a href="#322-Coin-Change" class="headerlink" title="322. Coin Change"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. Coin Change</a></h1><p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p><p>You may assume that you have an infinite number of each kind of coin.</p><p>Example 1:</p><p>Input: coins = [1,2,5], amount = 11<br>Output: 3<br>Explanation: 11 = 5 + 5 + 1<br>Example 2:</p><p>Input: coins = [2], amount = 3<br>Output: -1<br>Example 3:</p><p>Input: coins = [1], amount = 0<br>Output: 0<br>Example 4:</p><p>Input: coins = [1], amount = 1<br>Output: 1<br>Example 5:</p><p>Input: coins = [1], amount = 2<br>Output: 2</p><p>Constraints:</p><p>1 &lt;= coins.length &lt;= 12<br>1 &lt;= coins[i] &lt;= 231 - 1<br>0 &lt;= amount &lt;= 104</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;count;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> rem)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rem &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (rem == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (count[rem - <span class="number">1</span>] != <span class="number">0</span>) <span class="keyword">return</span> count[rem - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> Min = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin:coins) &#123;</span><br><span class="line">            <span class="keyword">int</span> res = dp(coins, rem - coin);</span><br><span class="line">            <span class="keyword">if</span> (res &gt;= <span class="number">0</span> &amp;&amp; res &lt; Min) &#123;</span><br><span class="line">                Min = res + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count[rem - <span class="number">1</span>] = Min == INT_MAX ? <span class="number">-1</span> : Min;</span><br><span class="line">        <span class="keyword">return</span> count[rem - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        count.resize(amount);</span><br><span class="line">        <span class="keyword">return</span> dp(coins, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(sn)$  s: amount, n: number of the coin.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;322-Coin-Change&quot;&gt;&lt;a href=&quot;#322-Coin-Change&quot; class=&quot;headerlink&quot; title=&quot;322. Coin Change&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problem
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>LeetCode509. Fibonacci Number</title>
    <link href="https://github.com/liysky/liysky.github.io.git/2020/12/05/LeetCode509-Fibonacci-Number/"/>
    <id>https://github.com/liysky/liysky.github.io.git/2020/12/05/LeetCode509-Fibonacci-Number/</id>
    <published>2020-12-05T13:57:25.000Z</published>
    <updated>2020-12-05T13:58:07.287Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-509-Fibonacci-Number"><a href="#LeetCode-509-Fibonacci-Number" class="headerlink" title="LeetCode 509. Fibonacci Number"></a><a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">LeetCode 509. Fibonacci Number</a></h1><p>The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,</p><p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), for N &gt; 1.<br>Given N, calculate F(N).</p><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><p>Input: 2<br>Output: 1<br>Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.</p><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h3><p>Input: 3<br>Output: 2<br>Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.</p><h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3:"></a>Example 3:</h3><p>Input: 4<br>Output: 3<br>Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.</p><p><strong>Note: 0 ≤ N ≤ 30.</strong></p><p>According to the description of example, it easy to code the straight code following:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(N == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> (fib(N - <span class="number">1</span>) + fib(N - <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(2^n)$  the number of subproblem is $2^n$, and the time subproblem spent is 1</p><p>space complexity: $O(1)$</p><hr><p>Having a note to memory the value of the node.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mem</span> <span class="params">(N+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> notes(mem, N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">notes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;mem, <span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">1</span> || N == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mem[N] != <span class="number">0</span>) <span class="keyword">return</span> mem[N];</span><br><span class="line">        mem[N] = notes(mem, N<span class="number">-1</span>) + notes(mem, N<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">return</span> mem[N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$</p><p>space complexity: $O(n)$</p><hr><p>If we have a DP table to record the value of different node.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(N == <span class="number">1</span> || N == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">table</span><span class="params">(N+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">      table[<span class="number">1</span>] = table[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N+<span class="number">1</span>; i++)&#123;</span><br><span class="line">          table[N] = table[N<span class="number">-1</span>] + table[N<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> table[N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$</p><p>space complexity: $O(n)$</p><p>if we use point to record the previous and current value of the table, just like control a table using point in data structure. Then we can deprecate the table.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(N == <span class="number">1</span> || N == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      pre = cur = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N+<span class="number">1</span>; i++)&#123;</span><br><span class="line">          <span class="keyword">int</span> sum = pre + cur;</span><br><span class="line">          pre = cur;</span><br><span class="line">          cur = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>then space complexity is $O(1)$</p><hr><p>reference: <a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode-509-Fibonacci-Number&quot;&gt;&lt;a href=&quot;#LeetCode-509-Fibonacci-Number&quot; class=&quot;headerlink&quot; title=&quot;LeetCode 509. Fibonacci Number&quot;&gt;&lt;/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Learn AndrewNg-MachineLearning notes</title>
    <link href="https://github.com/liysky/liysky.github.io.git/2020/11/28/Learn-AndrewNg-Ai-notes/"/>
    <id>https://github.com/liysky/liysky.github.io.git/2020/11/28/Learn-AndrewNg-Ai-notes/</id>
    <published>2020-11-28T14:28:31.000Z</published>
    <updated>2020-12-05T06:03:38.722Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Supervised-Leaning"><a href="#Supervised-Leaning" class="headerlink" title="Supervised Leaning:"></a>Supervised Leaning:</h3><p>e.g.</p><ul><li><p>Housing price prediction. (Regression) 房屋租价预测</p></li><li><p>Breast cancer(maligant, benign). (Classification) 乳腺癌的恶性良性预测</p></li></ul><h3 id="Unsupervised-Leaning"><a href="#Unsupervised-Leaning" class="headerlink" title="Unsupervised Leaning:"></a>Unsupervised Leaning:</h3><p>e.g.</p><ul><li><p>Google news. 谷歌新闻的分类（采用聚类的方法）</p></li><li><p>DNA Classification. DNA的分类，聚类算法</p></li><li><p>组织计算机集群（什么样的机器易于协同工作，进而高效）</p></li><li><p>Facebook、Google+ 的圈子分类</p></li><li><p>大公司大型数据，存储消费者信息进行，市场分类，细分市场</p></li><li><p>cocktail party 鸡尾酒🍸的酒宴中麦克风记录不同的声音，通过机器学习进行分辨出不同的声音（人声，歌声，噪声）</p></li></ul><h3 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h3><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201128001043034.png" alt="image-20201128001043034" style="zoom:80%;" /></p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201128001208038.png" alt="image-20201128001208038" style="zoom:80%;" /></p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201128001331719.png" alt="image-20201128001331719"  /></p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201128002225309.png" alt="image-20201128002225309"></p><p>代价函数 theta</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201128001331719.png" alt="image-20201128001331719"  /></p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201128002225309.png" alt="image-20201128002225309"></p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201128002355980.png" alt="image-20201128002355980"  /></p><p><strong>代价函数的作用</strong></p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201128002539163.png" alt="image-20201128002539163" style="zoom:80%;" /></p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201128002714684.png" alt="image-20201128002714684"></p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201128002714684.png" alt="image-20201128002714684"></p><p><strong>使用等高线来代表代价函数</strong></p><p>contour plot 等高线图</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201128002952837.png" alt="image-20201128002952837" style="zoom:80%;" /></p><p>想象一下，这个等高线上长出一个碗来</p><p><strong>不同的代价函数对应不同的假设函数</strong></p><h3 id="梯度下降-Gradient-Decent"><a href="#梯度下降-Gradient-Decent" class="headerlink" title="梯度下降 Gradient Decent"></a>梯度下降 Gradient Decent</h3><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201128003530397.png" alt="image-20201128003530397" style="zoom:80%;" /></p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201128003554240.png" alt="image-20201128003554240" style="zoom:80%;" /></p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201128003757283.png" alt="image-20201128003757283" style="zoom:80%;" /></p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201128004027942.png" alt="image-20201128004027942" style="zoom:80%;" /></p><p>阿尔法是一个学习率，来控制梯度下降的速度</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201128004409451.png" alt="image-20201128004409451" style="zoom:80%;" /></p><p>左边的是正确的 simultaneous 同步更新</p><p>右边更新在更新时使用了更新的值，无同步</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201128005531564.png" alt="image-20201128005531564" style="zoom:80%;" /></p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201128005730763.png" alt="image-20201128005730763" style="zoom:80%;" /></p><p>如果步伐过大，将会越过最小值点</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201128005854145.png" alt="image-20201128005854145"></p><p>如果已经在最低点了，那么梯度下降算法将不会做任何事情</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201128010156987.png" alt="image-20201128010156987" style="zoom:80%;" /></p><h3 id="线性回归的梯度下降算法"><a href="#线性回归的梯度下降算法" class="headerlink" title="线性回归的梯度下降算法"></a>线性回归的梯度下降算法</h3><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201128010407579.png" alt="image-20201128010407579" style="zoom:80%;" /></p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201128010902400.png" alt="image-20201128010902400" style="zoom:80%;" /></p><p>将梯度下降算法应用到线性回归函数中后：</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201128011023572.png" alt="image-20201128011023572" style="zoom:80%;" /></p><p>当代价值越来越小时，将会最终到达最符合的拟合曲线</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201128011404831.png" alt="image-20201128011404831" style="zoom: 67%;" /></p><p>因为在每次计算代价函数的时候，都进行了对于m个数据集的计算，所以称之为batch，批处理</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201128011618967.png" alt="image-20201128011618967" style="zoom:80%;" /></p><p>除了梯度下降算法来求解代价函数的最小值，还有一个交做正规方程组方法可以使用。</p><p>梯度下降算法更适合于数据量大的计算。</p><h3 id="矩阵乘法的妙用"><a href="#矩阵乘法的妙用" class="headerlink" title="矩阵乘法的妙用"></a>矩阵乘法的妙用</h3><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201128233000407.png" alt="image-20201128233000407" style="zoom:80%;" /></p><p>python 中有关矩阵的乘法和转置</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201128233000407.png" alt="image-20201128233000407" style="zoom:80%;" /></p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201129005158320.png" alt="image-20201129005158320" style="zoom: 67%;" /></p><p>求逆时，如果为奇异矩阵-singular matrix ，将会有提示：</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201129010025788.png" alt="image-20201129010025788" style="zoom: 67%;" /></p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201129010226792.png" alt="image-20201129010226792" style="zoom: 67%;" /></p><p><strong>python中可以使用 pinv 的来计算奇异矩阵的伪逆矩阵</strong></p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201204103320335.png" alt="image-20201204103320335" style="zoom:80%;" /></p><h3 id="Multivariate-linear-regression-多元线性回归"><a href="#Multivariate-linear-regression-多元线性回归" class="headerlink" title="Multivariate linear regression 多元线性回归"></a>Multivariate linear regression 多元线性回归</h3><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201129110527040.png" alt="image-20201129110527040" style="zoom:80%;" /></p><p>New Hypothesis：</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201129110633901.png" alt="image-20201129110633901" style="zoom:80%;" /></p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201129111023093.png" alt="image-20201129111023093" style="zoom:80%;" /></p><h3 id="Gradient-descent多元梯度下降方法"><a href="#Gradient-descent多元梯度下降方法" class="headerlink" title="Gradient descent多元梯度下降方法"></a>Gradient descent多元梯度下降方法</h3><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201129111307808.png" alt="image-20201129111307808" style="zoom:80%;" /></p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201129111744934.png" alt="image-20201129111744934"></p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201129111744934.png" alt="image-20201129111744934"></p><h3 id="多元梯度下降-feature-scaling"><a href="#多元梯度下降-feature-scaling" class="headerlink" title="多元梯度下降  feature scaling"></a>多元梯度下降  feature scaling</h3><p>divide max  除以最大值方法</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201201170055672.png" alt="image-20201201170055672" style="zoom:80%;" /></p><p>feature scaling 之后更容易梯度下降至找到一个局部最小值</p><p>feature scaling 条件</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201201170317073.png" alt="image-20201201170317073"></p><p>除以平均值方法</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201201171035772.png" alt="image-20201201171035772" style="zoom:80%;" /></p><h3 id="多元梯度下降中的学习率-——阿尔法"><a href="#多元梯度下降中的学习率-——阿尔法" class="headerlink" title="多元梯度下降中的学习率 ——阿尔法"></a>多元梯度下降中的学习率 ——阿尔法</h3><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201201171819775.png" alt="image-20201201171819775" style="zoom:80%;" /></p><p>代价函数逐渐收敛</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201201172029595.png" alt="image-20201201172029595" style="zoom:80%;" /></p><p>学习率 阿尔法 的选择：</p><p>通常情况下是选择一个较小的学习率，但太小也会导致收敛速度变慢。</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201201172322418.png" alt="image-20201201172322418" style="zoom:80%;" /></p><p>选取学习率的方法</p><h3 id="特征和多项式回归"><a href="#特征和多项式回归" class="headerlink" title="特征和多项式回归"></a>特征和多项式回归</h3><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201203100047476.png" alt="image-20201203100047476" style="zoom:80%;" /></p><p>将 frontage  和 depth 重新定义为 area </p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201203100412974.png" alt="image-20201203100412974" style="zoom:80%;" /></p><p>更好二特征模型：</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201203100603941.png" alt="image-20201203100603941" style="zoom:80%;" /></p><h3 id="正规方程"><a href="#正规方程" class="headerlink" title="正规方程"></a>正规方程</h3><p>通常使用梯度下降的方法来求代价函数的最小值</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201203101955873.png" alt="image-20201203101955873" style="zoom:80%;" /></p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201203102336345.png" alt="image-20201203102336345" style="zoom:80%;" /></p><p>例如：</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201204111655518.png" alt="image-20201204111655518" style="zoom: 67%;" /></p><p>正规方程求代价函数最小值点</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201203102908070.png" alt="image-20201203102908070" style="zoom:80%;" /></p><p>如果使用正规方程发就不需要进行缩放操作。</p><p>正规方程解与梯度下降方法的对比：</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201203103213877.png" alt="image-20201203103213877" style="zoom:80%;" /></p><p>特征n数量多时，通常会选择梯度下降算法。</p><h3 id="When-matrix-is-non-invertible"><a href="#When-matrix-is-non-invertible" class="headerlink" title="When matrix is non-invertible"></a>When matrix is non-invertible</h3><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201203124741104.png" alt="image-20201203124741104" style="zoom:80%;" /></p><p>看特征里是否有相关特征，对应到线性代数即为是否为线性相关的</p><h3 id="Logistic-Regression-Classification-逻辑回归分类"><a href="#Logistic-Regression-Classification-逻辑回归分类" class="headerlink" title="Logistic Regression Classification  逻辑回归分类"></a>Logistic Regression Classification  逻辑回归分类</h3><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201205111311855.png" alt="image-20201205111311855"  /></p><p>线性回归应用于分类问题，通常不能永远的到一个好的结果。所以才有了后面的逻辑回归，得出一个永远的 h(theta) 函数的值在 0 ~ 1 之间。</p><h3 id="Logistic-Regression-Hypothesis-Representation-假设逻辑回归"><a href="#Logistic-Regression-Hypothesis-Representation-假设逻辑回归" class="headerlink" title="Logistic Regression Hypothesis Representation  假设逻辑回归"></a>Logistic Regression Hypothesis Representation  假设逻辑回归</h3><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201205111805487.png" alt="image-20201205111805487" style="zoom:80%;" /></p><p>sigmod function == logistic function</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201205112012525.png" alt="image-20201205112012525" style="zoom:80%;" /></p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/picgo/image-20201205112347863.png" alt="image-20201205112347863" style="zoom:80%;" /></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Supervised-Leaning&quot;&gt;&lt;a href=&quot;#Supervised-Leaning&quot; class=&quot;headerlink&quot; title=&quot;Supervised Leaning:&quot;&gt;&lt;/a&gt;Supervised Leaning:&lt;/h3&gt;&lt;p&gt;e.g.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>LeetCode-Hanota LCCI</title>
    <link href="https://github.com/liysky/liysky.github.io.git/2020/11/20/LeetCode-Hanota-LCCI/"/>
    <id>https://github.com/liysky/liysky.github.io.git/2020/11/20/LeetCode-Hanota-LCCI/</id>
    <published>2020-11-19T16:01:32.000Z</published>
    <updated>2020-11-20T04:29:37.225Z</updated>
    
    <content type="html"><![CDATA[<h3 id="08-06-Hanota-LCCI"><a href="#08-06-Hanota-LCCI" class="headerlink" title="08.06. Hanota LCCI"></a><a href="https://leetcode-cn.com/problems/hanota-lcci/" target="_blank" rel="noopener">08.06. Hanota LCCI</a></h3><p>In the classic problem of the Towers of Hanoi, you have 3 towers and N disks of different sizes which can slide onto any tower. The puzzle starts with disks sorted in ascending order of size from top to bottom (i.e., each disk sits on top of an even larger one). You have the following constraints:</p><p>(1) Only one disk can be moved at a time.<br>(2) A disk is slid off the top of one tower onto another tower.<br>(3) A disk cannot be placed on top of a smaller disk.</p><p>Write a program to move the disks from the first tower to the last using stacks.</p><h4 id="Example1"><a href="#Example1" class="headerlink" title="Example1:"></a>Example1:</h4><p> Input: A = [2, 1, 0], B = [], C = []<br> Output: C = [2, 1, 0]</p><h4 id="Example2"><a href="#Example2" class="headerlink" title="Example2:"></a>Example2:</h4><p> Input: A = [1, 0], B = [], C = []<br> Output: C = [1, 0]<br>Note:</p><p><strong>A.length &lt;= 14</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hanota</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; C)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">move</span>(n, A, B, C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; C)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            C.push_back(A.back());</span><br><span class="line">            A.pop_back();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">move</span>(n<span class="number">-1</span>, A, C, B);</span><br><span class="line">        C.push_back(A.back());</span><br><span class="line">        A.pop_back();</span><br><span class="line">        <span class="built_in">move</span>(n<span class="number">-1</span>, B, A, C);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>time complexity: $O(2^n-1)$</strong> . It’s the moving times.</p><p><strong>space complexity:</strong> $O(1)$</p><p><strong>Key Solution:</strong></p><ul><li>wanna resolve n number, first to resolve n-1</li><li>put <strong>n-1</strong> number of A into B using C</li><li>push_back A.back into C. (It’s a half answer that A.back must be at the bottum of C)</li><li>pop A.back(). (=delete A.back)</li><li>put <strong>n-1</strong> number of B into C using A</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;08-06-Hanota-LCCI&quot;&gt;&lt;a href=&quot;#08-06-Hanota-LCCI&quot; class=&quot;headerlink&quot; title=&quot;08.06. Hanota LCCI&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/p
      
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="https://github.com/liysky/liysky.github.io.git/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>DogsVSCats</title>
    <link href="https://github.com/liysky/liysky.github.io.git/2020/11/18/DogsVSCats/"/>
    <id>https://github.com/liysky/liysky.github.io.git/2020/11/18/DogsVSCats/</id>
    <published>2020-11-18T07:25:45.000Z</published>
    <updated>2020-11-25T09:54:40.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dog-VS-Cat"><a href="#Dog-VS-Cat" class="headerlink" title="Dog VS Cat"></a>Dog VS Cat</h1><h2 id="VGG网络"><a href="#VGG网络" class="headerlink" title="VGG网络"></a>VGG网络</h2><p>VGG 是一个卷积神经网络模型，是哈弗 Robotics Institute Visual Geometry Group 组的 Karen Simonyan 和 Andrew Zisserman  在2014年提出的。2014年在最大的图像识别竞赛 ILSVRC 中，这个模型获得第二名，第一名是 GoogleNet，VGG 模型在多个迁移学习任务中好于 GoogleNet。</p><p>VGG 是卷积神经网络的重大突破，在这些之后：</p><ul><li>LeNet-5 （1998）</li><li>AlexNet （2012）</li><li>ZFNet （2013）</li><li>GoogleNet/Inception （2014)</li></ul><p>注：AlexNet 的提出，使得大型卷积网络变得流行了起来。ZFNet 是基于 AlexNet 的一种模型改进。</p><p><strong>VGG的特点</strong></p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/main-qimg-4eb892d2fa56e21288ae723397f5f329.png" alt="img"></p><p>上图中，上面是AlexNet和下面VGG-16两种模型结构比较</p><p>AlexNet 包含有5个卷积层和3个全连接层，在第1、2和5卷积层使用了3个最大池化层</p><p>VGG-16 包含有13个卷积层，卷积核为3X3，3个全连接层</p><p>VGG-19包含了16个卷积层和3个全连接层</p><p>VGG 网络结构非常一致，从头到尾全部使用了  3X3 的卷积核和2X2的 max-pooling</p><p>VGG-16网络结构一镜到底：<a href="https://dgschwend.github.io/netscope/#/preset/vgg-16" target="_blank" rel="noopener">https://dgschwend.github.io/netscope/#/preset/vgg-16</a></p><h2 id="VGG-Dogs-VS-Cats"><a href="#VGG-Dogs-VS-Cats" class="headerlink" title="VGG Dogs VS Cats"></a>VGG Dogs VS Cats</h2><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201118152910384.png" alt="image-20201118152910384"></p><p><em>Description</em></p><ul><li><p><a href="https://god.yanxishe.com/41" target="_blank" rel="noopener">https://god.yanxishe.com/41</a></p></li><li><p><a href="https://www.kaggle.com/tongpython/cat-and-dog" target="_blank" rel="noopener">https://www.kaggle.com/tongpython/cat-and-dog</a></p></li></ul><p>本次作业实现使用预训练好的 VGG 模型，下载Imagenet 1000 个类的 JSON 文件。</p><p>VGG 模型网络组成元素：</p><ul><li>卷积层（CONV）是发现图像中局部的 pattern</li><li>全连接层（FC）是在全局上建立特征的关联</li><li>池化（Pool）是给图像将维以提高特征的invariance</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> models,transforms,datasets</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否存在GPU设备</span></span><br><span class="line">device = torch.device(<span class="string">"cuda:0"</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line">print(<span class="string">'Using gpu:&#123;&#125;'</span>.format(torch.cuda.is_available()) )</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Using: gpu:True</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载数据并解压</span></span><br><span class="line">! wget http://fenggao-image.stor.sinaapp.com/dogscats.zip</span><br><span class="line">! unzip dogscats.zip</span><br></pre></td></tr></table></figure><hr><p><strong>数据处理</strong></p><ul><li><p>图片裁剪</p></li><li><p>转换为 tensor 格式</p><p>因为图片读入后为 numpy 格式，需要在 pytorch中进行处理，就需要转化为 tensor 的格式。</p><p>至于 tensor 的含义：</p><p><strong>tensor：张量</strong></p><blockquote><p>是一个可用来表示在一些<a href="https://zh.wikipedia.org/wiki/向量" target="_blank" rel="noopener">矢量</a>、<a href="https://zh.wikipedia.org/wiki/純量" target="_blank" rel="noopener">标量</a>和其他张量之间的线性关系的<a href="https://zh.wikipedia.org/wiki/线性形式" target="_blank" rel="noopener">多线性函数</a>，这些线性关系的基本例子有<a href="https://zh.wikipedia.org/wiki/內積" target="_blank" rel="noopener">内积</a>、<a href="https://zh.wikipedia.org/wiki/外積" target="_blank" rel="noopener">外积</a>、线性映射以及<a href="https://zh.wikipedia.org/wiki/笛卡儿积" target="_blank" rel="noopener">笛卡儿积</a>。</p><p>—wikipedia</p></blockquote><p>概念：能够用指标表示法表示的物理量，并且该物理量满足坐标变换关系。</p><ul><li>0阶张量：无自由指标的量，与坐标系选取无关，如温度、质量、能量等标量</li><li>1阶张量（向量）：有一个自由指标的量，如坐标 <script type="math/tex">{x_i}</script>，位移等矢量</li><li>2阶张量：有2个自由指标的量，如应力，应变等</li><li>3阶张量：如数据立方</li></ul><p>在深度学习里，张量即为一个多维数组，其可以创建更高维度的矩阵</p><p>Tensor对象的3个属性：</p><ul><li>Rank： number of dimensions</li><li>Shape: number of rows and columns</li><li>Type: data type of tensor’s elements</li></ul></li><li><p>归一化</p><ul><li>不同的图片映射到同一坐标系，拥有相同的尺度</li><li>像素值大小不同的问题转化为具有相似特征分布的问题</li><li>一定程度上消除了因为过度曝光，质量不佳或者噪声等各种原因对模型权值更新的影响</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">normalize = transforms.Normalize(mean=[<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>], std=[<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>]) <span class="comment">#归一化每个通道的平均值和标准差</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式整合</span></span><br><span class="line">vgg_format = transforms.Compose([</span><br><span class="line">    <span class="comment"># 将每个图片进行裁剪，CenterCrop参数有两个，只有一个时为正方形</span></span><br><span class="line">                transforms.CenterCrop(<span class="number">224</span>), </span><br><span class="line">    <span class="comment"># 将numpy数据格式转换为tensor格式</span></span><br><span class="line">                transforms.ToTensor(),   </span><br><span class="line">                <span class="comment">#归一化</span></span><br><span class="line">    normalize,          </span><br><span class="line">            ])                  </span><br><span class="line"></span><br><span class="line">data_dir = <span class="string">'./dogscats'</span></span><br><span class="line"></span><br><span class="line">dsets = &#123;x: datasets.ImageFolder(os.path.join(data_dir, x), vgg_format)</span><br><span class="line">         <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">'train'</span>, <span class="string">'valid'</span>]&#125;</span><br><span class="line"></span><br><span class="line">dset_sizes = &#123;x: len(dsets[x]) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">'train'</span>, <span class="string">'valid'</span>]&#125;</span><br><span class="line">dset_classes = dsets[<span class="string">'train'</span>].classes</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 训练时 shuffle是true，当检验时则为False</span></span><br><span class="line">loader_train = torch.utils.data.DataLoader(dsets[<span class="string">'train'</span>], batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">6</span>)</span><br><span class="line">loader_valid = torch.utils.data.DataLoader(dsets[<span class="string">'valid'</span>], batch_size=<span class="number">5</span>, shuffle=<span class="literal">False</span>, num_workers=<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">valid 数据一共有2000张图，每个batch是5张，因此，下面进行遍历一共会输出到 400</span></span><br><span class="line"><span class="string">同时，把第一个 batch 保存到 inputs_try, labels_try，分别查看</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">count = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> loader_valid:</span><br><span class="line">    print(count, end=<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">1</span>:</span><br><span class="line">        inputs_try,labels_try = data</span><br><span class="line">    count +=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(labels_try)</span><br><span class="line">print(inputs_try.shape)</span><br></pre></td></tr></table></figure></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">400</span><br><span class="line">tensor([0, 0, 0, 0, 0])</span><br><span class="line">torch.Size([5, 3, 224, 224])</span><br></pre></td></tr></table></figure><h3 id="模型下载-，创建-VGG-Model"><a href="#模型下载-，创建-VGG-Model" class="headerlink" title="模型下载 ，创建 VGG Model"></a>模型下载 ，创建 VGG Model</h3><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!wget https://s3.amazonaws.com/deep-learning-models/image-models/imagenet_class_index.json</span><br></pre></td></tr></table></figure></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--2020-11-17 06:42:58--  https:&#x2F;&#x2F;s3.amazonaws.com&#x2F;deep-learning-models&#x2F;image-models&#x2F;imagenet_class_index.json</span><br><span class="line">Resolving s3.amazonaws.com (s3.amazonaws.com)... 52.216.169.189</span><br><span class="line">Connecting to s3.amazonaws.com (s3.amazonaws.com)|52.216.169.189|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 35363 (35K) [application&#x2F;octet-stream]</span><br><span class="line">Saving to: ‘imagenet_class_index.json’</span><br><span class="line"></span><br><span class="line">imagenet_class_inde 100%[&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;]  34.53K  --.-KB&#x2F;s    in 0.09s   </span><br><span class="line"></span><br><span class="line">2020-11-17 06:42:58 (405 KB&#x2F;s) - ‘imagenet_class_index.json’ saved [35363&#x2F;35363]</span><br></pre></td></tr></table></figure><p>创建的是 VGG16 模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">model_vgg = models.vgg16(pretrained=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'./imagenet_class_index.json'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    class_dict = json.load(f)</span><br><span class="line">dic_imagenet = [class_dict[str(i)][<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(class_dict))]</span><br><span class="line"></span><br><span class="line">inputs_try , labels_try = inputs_try.to(device), labels_try.to(device)</span><br><span class="line">model_vgg = model_vgg.to(device)</span><br><span class="line"></span><br><span class="line">outputs_try = model_vgg(inputs_try)</span><br><span class="line"></span><br><span class="line">print(outputs_try)</span><br><span class="line">print(outputs_try.shape)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">可以看到结果为5行，1000列的数据，每一列代表对每一种目标识别的结果。</span></span><br><span class="line"><span class="string">但是我也可以观察到，结果非常奇葩，有负数，有正数，</span></span><br><span class="line"><span class="string">为了将VGG网络输出的结果转化为对每一类的预测概率，我们把结果输入到 Softmax 函数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">m_softm = nn.Softmax(dim=<span class="number">1</span>)</span><br><span class="line">probs = m_softm(outputs_try)</span><br><span class="line">vals_try,pred_try = torch.max(probs,dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print( <span class="string">'prob sum: '</span>, torch.sum(probs,<span class="number">1</span>))</span><br><span class="line">print( <span class="string">'vals_try: '</span>, vals_try)</span><br><span class="line">print( <span class="string">'pred_try: '</span>, pred_try)</span><br><span class="line"></span><br><span class="line">print([dic_imagenet[i] <span class="keyword">for</span> i <span class="keyword">in</span> pred_try.data])</span><br><span class="line">imshow(torchvision.utils.make_grid(inputs_try.data.cpu()), </span><br><span class="line">       title=[dset_classes[x] <span class="keyword">for</span> x <span class="keyword">in</span> labels_try.data.cpu()])</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Downloading: &quot;https:&#x2F;&#x2F;download.pytorch.org&#x2F;models&#x2F;vgg16-397923af.pth&quot; to &#x2F;root&#x2F;.cache&#x2F;torch&#x2F;hub&#x2F;checkpoints&#x2F;vgg16-397923af.pth</span><br><span class="line">100%</span><br><span class="line">528M&#x2F;528M [00:38&lt;00:00, 14.3MB&#x2F;s]</span><br><span class="line"></span><br><span class="line">tensor([[ 0.7979,  1.5667,  0.8546,  ...,  3.1719,  3.3310,  1.1075],</span><br><span class="line">        [-1.1246,  2.7357, -1.9035,  ..., -5.2773,  5.4166,  6.0531],</span><br><span class="line">        [-2.8606, -2.5214, -1.5476,  ..., -3.1250,  0.7820,  3.6555],</span><br><span class="line">        [-0.8027, -1.4977,  2.9460,  ..., -3.7837, -0.4200,  5.5966],</span><br><span class="line">        [-2.6016, -4.2326, -2.6736,  ..., -4.2833,  0.4802,  2.5251]],</span><br><span class="line">       device&#x3D;&#39;cuda:0&#39;, grad_fn&#x3D;&lt;AddmmBackward&gt;)</span><br><span class="line">torch.Size([5, 1000])</span><br><span class="line">prob sum:  tensor([1.0000, 1.0000, 1.0000, 1.0000, 1.0000], device&#x3D;&#39;cuda:0&#39;,</span><br><span class="line">       grad_fn&#x3D;&lt;SumBackward1&gt;)</span><br><span class="line">vals_try:  tensor([0.2639, 0.9191, 0.5210, 0.8608, 0.3465], device&#x3D;&#39;cuda:0&#39;,</span><br><span class="line">       grad_fn&#x3D;&lt;MaxBackward0&gt;)</span><br><span class="line">pred_try:  tensor([333, 281, 281, 281, 359], device&#x3D;&#39;cuda:0&#39;)</span><br><span class="line">[&#39;hamster&#39;, &#39;tabby&#39;, &#39;tabby&#39;, &#39;tabby&#39;, &#39;black-footed_ferret&#39;]</span><br></pre></td></tr></table></figure><h3 id="修改模型"><a href="#修改模型" class="headerlink" title="修改模型"></a>修改模型</h3><p>修改最后一层网络，冻结前面层的参数，使用预训练好的模型，需要把最后的 nn.Linear 层由 1000类替换为 2类。</p><p>为了在训练中冻结前面层的参数，需要设置 required_grad=False。这样，反向传播训练梯度时，前面层的权重就不会自动更新了，训练中，只会更新最后一层的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">print(model_vgg)</span><br><span class="line"></span><br><span class="line">model_vgg_new = model_vgg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> model_vgg_new.parameters():</span><br><span class="line">    param.requires_grad = <span class="literal">False</span></span><br><span class="line">model_vgg_new.classifier._modules[<span class="string">'6'</span>] = nn.Linear(<span class="number">4096</span>, <span class="number">2</span>)</span><br><span class="line">model_vgg_new.classifier._modules[<span class="string">'7'</span>] = torch.nn.LogSoftmax(dim = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">model_vgg_new = model_vgg_new.to(device)</span><br><span class="line"></span><br><span class="line">print(model_vgg_new.classifier)</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">VGG(</span><br><span class="line">  (features): Sequential(</span><br><span class="line">    (0): Conv2d(3, 64, kernel_size&#x3D;(3, 3), stride&#x3D;(1, 1), padding&#x3D;(1, 1))</span><br><span class="line">    (1): ReLU(inplace&#x3D;True)</span><br><span class="line">    (2): Conv2d(64, 64, kernel_size&#x3D;(3, 3), stride&#x3D;(1, 1), padding&#x3D;(1, 1))</span><br><span class="line">    (3): ReLU(inplace&#x3D;True)</span><br><span class="line">    (4): MaxPool2d(kernel_size&#x3D;2, stride&#x3D;2, padding&#x3D;0, dilation&#x3D;1, ceil_mode&#x3D;False)</span><br><span class="line">    (5): Conv2d(64, 128, kernel_size&#x3D;(3, 3), stride&#x3D;(1, 1), padding&#x3D;(1, 1))</span><br><span class="line">    (6): ReLU(inplace&#x3D;True)</span><br><span class="line">    (7): Conv2d(128, 128, kernel_size&#x3D;(3, 3), stride&#x3D;(1, 1), padding&#x3D;(1, 1))</span><br><span class="line">    (8): ReLU(inplace&#x3D;True)</span><br><span class="line">    (9): MaxPool2d(kernel_size&#x3D;2, stride&#x3D;2, padding&#x3D;0, dilation&#x3D;1, ceil_mode&#x3D;False)</span><br><span class="line">    (10): Conv2d(128, 256, kernel_size&#x3D;(3, 3), stride&#x3D;(1, 1), padding&#x3D;(1, 1))</span><br><span class="line">    (11): ReLU(inplace&#x3D;True)</span><br><span class="line">    (12): Conv2d(256, 256, kernel_size&#x3D;(3, 3), stride&#x3D;(1, 1), padding&#x3D;(1, 1))</span><br><span class="line">    (13): ReLU(inplace&#x3D;True)</span><br><span class="line">    (14): Conv2d(256, 256, kernel_size&#x3D;(3, 3), stride&#x3D;(1, 1), padding&#x3D;(1, 1))</span><br><span class="line">    (15): ReLU(inplace&#x3D;True)</span><br><span class="line">    (16): MaxPool2d(kernel_size&#x3D;2, stride&#x3D;2, padding&#x3D;0, dilation&#x3D;1, ceil_mode&#x3D;False)</span><br><span class="line">    (17): Conv2d(256, 512, kernel_size&#x3D;(3, 3), stride&#x3D;(1, 1), padding&#x3D;(1, 1))</span><br><span class="line">    (18): ReLU(inplace&#x3D;True)</span><br><span class="line">    (19): Conv2d(512, 512, kernel_size&#x3D;(3, 3), stride&#x3D;(1, 1), padding&#x3D;(1, 1))</span><br><span class="line">    (20): ReLU(inplace&#x3D;True)</span><br><span class="line">    (21): Conv2d(512, 512, kernel_size&#x3D;(3, 3), stride&#x3D;(1, 1), padding&#x3D;(1, 1))</span><br><span class="line">    (22): ReLU(inplace&#x3D;True)</span><br><span class="line">    (23): MaxPool2d(kernel_size&#x3D;2, stride&#x3D;2, padding&#x3D;0, dilation&#x3D;1, ceil_mode&#x3D;False)</span><br><span class="line">    (24): Conv2d(512, 512, kernel_size&#x3D;(3, 3), stride&#x3D;(1, 1), padding&#x3D;(1, 1))</span><br><span class="line">    (25): ReLU(inplace&#x3D;True)</span><br><span class="line">    (26): Conv2d(512, 512, kernel_size&#x3D;(3, 3), stride&#x3D;(1, 1), padding&#x3D;(1, 1))</span><br><span class="line">    (27): ReLU(inplace&#x3D;True)</span><br><span class="line">    (28): Conv2d(512, 512, kernel_size&#x3D;(3, 3), stride&#x3D;(1, 1), padding&#x3D;(1, 1))</span><br><span class="line">    (29): ReLU(inplace&#x3D;True)</span><br><span class="line">    (30): MaxPool2d(kernel_size&#x3D;2, stride&#x3D;2, padding&#x3D;0, dilation&#x3D;1, ceil_mode&#x3D;False)</span><br><span class="line">  )</span><br><span class="line">  (avgpool): AdaptiveAvgPool2d(output_size&#x3D;(7, 7))</span><br><span class="line">  (classifier): Sequential(</span><br><span class="line">    (0): Linear(in_features&#x3D;25088, out_features&#x3D;4096, bias&#x3D;True)</span><br><span class="line">    (1): ReLU(inplace&#x3D;True)</span><br><span class="line">    (2): Dropout(p&#x3D;0.5, inplace&#x3D;False)</span><br><span class="line">    (3): Linear(in_features&#x3D;4096, out_features&#x3D;4096, bias&#x3D;True)</span><br><span class="line">    (4): ReLU(inplace&#x3D;True)</span><br><span class="line">    (5): Dropout(p&#x3D;0.5, inplace&#x3D;False)</span><br><span class="line">    (6): Linear(in_features&#x3D;4096, out_features&#x3D;1000, bias&#x3D;True)</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line">Sequential(</span><br><span class="line">  (0): Linear(in_features&#x3D;25088, out_features&#x3D;4096, bias&#x3D;True)</span><br><span class="line">  (1): ReLU(inplace&#x3D;True)</span><br><span class="line">  (2): Dropout(p&#x3D;0.5, inplace&#x3D;False)</span><br><span class="line">  (3): Linear(in_features&#x3D;4096, out_features&#x3D;4096, bias&#x3D;True)</span><br><span class="line">  (4): ReLU(inplace&#x3D;True)</span><br><span class="line">  (5): Dropout(p&#x3D;0.5, inplace&#x3D;False)</span><br><span class="line">  (6): Linear(in_features&#x3D;4096, out_features&#x3D;2, bias&#x3D;True)</span><br><span class="line">  (7): LogSoftmax(dim&#x3D;1)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="训练并测试全连接层"><a href="#训练并测试全连接层" class="headerlink" title="训练并测试全连接层"></a>训练并测试全连接层</h3><p><strong>三个步骤</strong></p><ul><li>创建损失函数和优化器</li><li>训练模型</li><li>测试模型</li></ul><p>在这里，改用 Adam 替换 SGD 优化器</p><ul><li><p>SGD （Stochastic Gradient Descent）朴素梯度下降，最为简单，没有动量的概念。</p><p>缺点在于：收敛速度慢，可能在鞍点（沿着某一个方向是稳定的另一个方向是不稳定的，物理含义即一个方向上是极大值，另一个方向上是极小值）处震荡。</p><p>为了跳出鞍点处，提出了动量的概念因此有了几种改进的优化器</p></li><li><p>Adam 简单说是一种添加了动量的梯度下降优化器，大大提高了收敛的速度。</p><p>缺点在于：可能越过全局最优解；某些情况可能不收敛</p></li></ul><p>在这里设置一个最大精度值max_acc，每一个 epoch 都与之进行比较，当新的 epoch 精度更好时替换之，保存训练出的最好的模型和最后一个训练的模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">第一步：创建损失函数和优化器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">损失函数 NLLLoss() 的 输入 是一个对数概率向量和一个目标标签. </span></span><br><span class="line"><span class="string">它不会为我们计算对数概率，适合最后一层是log_softmax()的网络. </span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> trange,tqdm</span><br><span class="line">criterion = nn.NLLLoss()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 学习率</span></span><br><span class="line">lr = (<span class="number">1e-3</span>)/<span class="number">2</span>/<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机梯度下降</span></span><br><span class="line">optimizer_vgg = torch.optim.Adam(model_vgg_new.classifier[<span class="number">6</span>].parameters(),lr = lr)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">第二步：训练模型</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_model</span><span class="params">(model,dataloader,size,epochs=<span class="number">1</span>,optimizer=None)</span>:</span></span><br><span class="line">    model.train()</span><br><span class="line">    </span><br><span class="line">    max_acc = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs):</span><br><span class="line">        running_loss = <span class="number">0.0</span></span><br><span class="line">        running_corrects = <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> inputs,classes <span class="keyword">in</span> dataloader:</span><br><span class="line">            inputs = inputs.to(device)</span><br><span class="line">            classes = classes.to(device)</span><br><span class="line">            outputs = model(inputs)</span><br><span class="line">            loss = criterion(outputs,classes)           </span><br><span class="line">            optimizer = optimizer</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">            _,preds = torch.max(outputs.data,<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># statistics</span></span><br><span class="line">            running_loss += loss.data.item()</span><br><span class="line">            running_corrects += torch.sum(preds == classes.data)</span><br><span class="line">            count += len(inputs)</span><br><span class="line">            print(<span class="string">'Training: No. '</span>, count, <span class="string">' process ... total: '</span>, size)</span><br><span class="line">        epoch_loss = running_loss / size</span><br><span class="line">        epoch_acc = running_corrects.data.item() / size</span><br><span class="line">        print(<span class="string">'Loss: &#123;:.4f&#125; Acc: &#123;:.4f&#125;'</span>.format(</span><br><span class="line">                     epoch_loss, epoch_acc))</span><br><span class="line">                    <span class="comment">#/content/imagenet_class_index.json</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> epoch_acc&gt;max_acc:</span><br><span class="line">            max_acc = epoch_acc</span><br><span class="line">            torch.save(model, <span class="string">'/content/model_best_new.pth'</span>)</span><br><span class="line">            <span class="comment"># tqdm.write("\n Got A Nice Model Acc:&#123;:.8f&#125;".format(max_acc))</span></span><br><span class="line">        tqdm.write(<span class="string">'\nepoch: &#123;&#125; \tLoss: &#123;:.8f&#125; Acc: &#123;:.8f&#125;'</span>.format(epoch,epoch_loss, epoch_acc))</span><br><span class="line">        tqdm.write(<span class="string">'\n Best acc is: &#123;&#125; \n'</span>.format(max_acc))</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line"> </span><br><span class="line">    torch.save(model, <span class="string">'/content/model_last_new.pth'</span>)</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment"># 模型训练</span></span><br><span class="line">train_model(model_vgg_new,loader_train,size=dset_sizes[<span class="string">'train'</span>], epochs=<span class="number">10</span>, </span><br><span class="line">            optimizer=optimizer_vgg)</span><br></pre></td></tr></table></figure><hr><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201119132604195.png" alt="image-20201119132604195"></p><p>（epochs 起初改为100，后来发现改为10，效果也已经不错了）</p><h3 id="valid-数据模型测试"><a href="#valid-数据模型测试" class="headerlink" title="valid 数据模型测试"></a>valid 数据模型测试</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_model</span><span class="params">(model,dataloader,size)</span>:</span></span><br><span class="line">    model.eval()</span><br><span class="line">    predictions = np.zeros(size)</span><br><span class="line">    all_classes = np.zeros(size)</span><br><span class="line">    all_proba = np.zeros((size,<span class="number">2</span>))</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    running_corrects = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> inputs,classes <span class="keyword">in</span> dataloader:</span><br><span class="line">        inputs = inputs.to(device)</span><br><span class="line">        classes = classes.to(device)</span><br><span class="line">        outputs = model(inputs)</span><br><span class="line">        loss = criterion(outputs,classes)           </span><br><span class="line">        _,preds = torch.max(outputs.data,<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># statistics</span></span><br><span class="line">        running_loss += loss.data.item()</span><br><span class="line">        running_corrects += torch.sum(preds == classes.data)</span><br><span class="line">        predictions[i:i+len(classes)] = preds.to(<span class="string">'cpu'</span>).numpy()</span><br><span class="line">        all_classes[i:i+len(classes)] = classes.to(<span class="string">'cpu'</span>).numpy()</span><br><span class="line">        all_proba[i:i+len(classes),:] = outputs.data.to(<span class="string">'cpu'</span>).numpy()</span><br><span class="line">        i += len(classes)</span><br><span class="line">        print(<span class="string">'Testing: No. '</span>, i, <span class="string">' process ... total: '</span>, size)        </span><br><span class="line">    epoch_loss = running_loss / size</span><br><span class="line">    epoch_acc = running_corrects.data.item() / size</span><br><span class="line">    print(<span class="string">'Loss: &#123;:.4f&#125; Acc: &#123;:.4f&#125;'</span>.format(</span><br><span class="line">                     epoch_loss, epoch_acc))</span><br><span class="line">    <span class="keyword">return</span> predictions, all_proba, all_classes</span><br><span class="line">  </span><br><span class="line">predictions, all_proba, all_classes = test_model(model_vgg_new,loader_valid,size=dset_sizes[<span class="string">'valid'</span>])</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Testing: No.  5  process ... total:  2000</span><br><span class="line">Testing: No.  10  process ... total:  2000</span><br><span class="line">Testing: No.  15  process ... total:  2000</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">Testing: No.  1995  process ... total:  2000</span><br><span class="line">Testing: No.  2000  process ... total:  2000</span><br><span class="line">Loss: 0.0105 Acc: 0.9795</span><br></pre></td></tr></table></figure><h3 id="研习社-test-数据测试"><a href="#研习社-test-数据测试" class="headerlink" title="研习社 test 数据测试"></a>研习社 test 数据测试</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载测试数据</span></span><br><span class="line">dsets_mine = datasets.ImageFolder(<span class="string">"/content/yanxishe/"</span>, vgg_format)</span><br><span class="line"> </span><br><span class="line">loader_test = torch.utils.data.DataLoader(dsets_mine, batch_size=<span class="number">1</span>, shuffle=<span class="literal">False</span>, num_workers=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 加载 best model</span></span><br><span class="line">model_vgg_new = torch.load(<span class="string">r'/content/model_best_new.pth'</span>)</span><br><span class="line">model_vgg_new = model_vgg_new.to(device)</span><br><span class="line"></span><br><span class="line">dic = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(model,dataloader,size)</span>:</span></span><br><span class="line">    model.eval()</span><br><span class="line">    predictions = np.zeros(size)</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> inputs,_ <span class="keyword">in</span> tqdm(dataloader):</span><br><span class="line">        inputs = inputs.to(device)</span><br><span class="line">        outputs = model(inputs)</span><br><span class="line">        _,preds = torch.max(outputs.data,<span class="number">1</span>)    </span><br><span class="line">        key = dsets_mine.imgs[cnt][<span class="number">0</span>].split(<span class="string">"\\"</span>)[<span class="number">-1</span>].split(<span class="string">'.'</span>)[<span class="number">0</span>]</span><br><span class="line">        dic[key] = preds[<span class="number">0</span>]</span><br><span class="line">        cnt = cnt +<span class="number">1</span></span><br><span class="line">test(model_vgg_new,loader_test,size=<span class="number">2000</span>)</span><br></pre></td></tr></table></figure><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201119132146392.png" alt="image-20201119132146392"></p><p>将测试结果 dic 按顺序写入 csv 文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"result1.csv"</span>,<span class="string">'a+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> range(<span class="number">2000</span>):</span><br><span class="line">        f.write(<span class="string">"&#123;&#125;,&#123;&#125;\n"</span>.format(key, dic[<span class="string">"/content/yanxishe/test/"</span>+str(key)]))</span><br></pre></td></tr></table></figure><h3 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h3><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201119141718413.png" alt="image-20201119141718413"></p><p>最早的结果是训练 epoch 修改为100，SGD优化器时，训练 Acc 为0.99时获得的。</p><p>第二个是修改优化器为 Adam 时的结果， Acc 同样为0.99时获得的结果。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>增加 epoch 数量会提高训练的准确度</p></li><li><p>优化器改为 Adam 会提高训练时收敛的速度，但对于结果好像没有太大的提升</p></li><li><p>当修改了学习率时，发现对 Acc 有不错的影响，选择 epoch = 10， 测试了 0.001 学习率，和0.005学习率，发现0.005可以在一开始时就获得比较高的 Acc。</p><p>对于学习率的设置有:</p></li></ul><div class="table-container"><table><thead><tr><th>学习率</th><th>大</th><th>小</th></tr></thead><tbody><tr><td>学习速度</td><td>快</td><td>慢</td></tr><tr><td>使用时间点</td><td>刚开始训练时</td><td>经过一定轮数后</td></tr><tr><td>副作用</td><td>1. 易损失值爆炸；2. 易震荡</td><td>1. 易过拟合；2. 收敛速度慢</td></tr></tbody></table></div><ul><li>设置一个最大精度值max_acc，每一个 epoch 的 Acc 都与之进行比较，当新的 epoch 精度更好时替换之，保存训练出的最好的模型。然后用最好的训练模型进行 valid 数据集测试和 test 数据集测试。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Dog-VS-Cat&quot;&gt;&lt;a href=&quot;#Dog-VS-Cat&quot; class=&quot;headerlink&quot; title=&quot;Dog VS Cat&quot;&gt;&lt;/a&gt;Dog VS Cat&lt;/h1&gt;&lt;h2 id=&quot;VGG网络&quot;&gt;&lt;a href=&quot;#VGG网络&quot; class=&quot;he
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>区域生长&amp;区域分割与合成&amp;分水岭算法</title>
    <link href="https://github.com/liysky/liysky.github.io.git/2020/11/14/region-growsplitmerge-watershed/"/>
    <id>https://github.com/liysky/liysky.github.io.git/2020/11/14/region-growsplitmerge-watershed/</id>
    <published>2020-11-14T05:49:54.000Z</published>
    <updated>2020-11-14T05:53:48.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区域生长算法，区域分裂与合成算法，分水岭分割算法"><a href="#区域生长算法，区域分裂与合成算法，分水岭分割算法" class="headerlink" title="区域生长算法，区域分裂与合成算法，分水岭分割算法"></a>区域生长算法，区域分裂与合成算法，分水岭分割算法</h1><h2 id="区域生长算法"><a href="#区域生长算法" class="headerlink" title="区域生长算法"></a>区域生长算法</h2><p><strong>算法实现</strong></p><ul><li>根据图像的不同应用选择一个或一组种子，它或为最亮或最暗或点簇中心的点</li><li>确定相似性准则即生长准则（条件）</li><li>从该种子开始不断向外扩张，首先将种子像素加入集合，然后不断将与几何中各个像素连通、且满足描述准则的像素加入集合</li><li>上一过程进行到不再有满足条件的新的节点加入集合为止</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"></span><br><span class="line"><span class="comment">#class pour une pile</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.item = []</span><br><span class="line">        self.obj=[]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.item.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.item.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.size() == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.item = []</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">regionGrow</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,im_path,th)</span>:</span></span><br><span class="line">        self.readImage(im_path)</span><br><span class="line">        self.h, self.w,_ =  self.im.shape</span><br><span class="line">        self.passedBy = np.zeros((self.h,self.w), np.double)</span><br><span class="line">        self.currentRegion = <span class="number">0</span></span><br><span class="line">        self.iterations=<span class="number">0</span></span><br><span class="line">        self.SEGS=np.zeros((self.h,self.w,<span class="number">3</span>), dtype=<span class="string">'uint8'</span>)</span><br><span class="line">        self.stack = Stack()</span><br><span class="line">        self.thresh=float(th)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readImage</span><span class="params">(self, img_path)</span>:</span></span><br><span class="line">        self.im = cv2.imread(img_path,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNeighbour</span><span class="params">(self, x0, y0)</span>:</span></span><br><span class="line">        neighbour = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> (<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> (i,j) == (<span class="number">0</span>,<span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                x = x0+i</span><br><span class="line">                y = y0+j</span><br><span class="line">                <span class="keyword">if</span> self.limit(x,y):</span><br><span class="line">                    neighbour.append((x,y))</span><br><span class="line">        <span class="keyword">return</span> neighbour</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ApplyRegionGrow</span><span class="params">(self)</span>:</span></span><br><span class="line">        randomseeds=[[self.h/<span class="number">2</span>,self.w/<span class="number">2</span>],</span><br><span class="line">            [self.h/<span class="number">3</span>,self.w/<span class="number">3</span>],[<span class="number">2</span>*self.h/<span class="number">3</span>,self.w/<span class="number">3</span>],[self.h/<span class="number">3</span><span class="number">-10</span>,self.w/<span class="number">3</span>],</span><br><span class="line">            [self.h/<span class="number">3</span>,<span class="number">2</span>*self.w/<span class="number">3</span>],[<span class="number">2</span>*self.h/<span class="number">3</span>,<span class="number">2</span>*self.w/<span class="number">3</span>],[self.h/<span class="number">3</span><span class="number">-10</span>,<span class="number">2</span>*self.w/<span class="number">3</span>],</span><br><span class="line">            [self.h/<span class="number">3</span>,self.w<span class="number">-10</span>],[<span class="number">2</span>*self.h/<span class="number">3</span>,self.w<span class="number">-10</span>],[self.h/<span class="number">3</span><span class="number">-10</span>,self.w<span class="number">-10</span>]</span><br><span class="line">                    ]</span><br><span class="line">        np.random.shuffle(randomseeds)</span><br><span class="line">        <span class="keyword">for</span> x0 <span class="keyword">in</span> range (self.h):</span><br><span class="line">            <span class="keyword">for</span> y0 <span class="keyword">in</span> range (self.w):</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> self.passedBy[x0,y0] == <span class="number">0</span> <span class="keyword">and</span> (int(self.im[x0,y0,<span class="number">0</span>])*int(self.im[x0,y0,<span class="number">1</span>])*int(self.im[x0,y0,<span class="number">2</span>]) &gt; <span class="number">0</span>) :</span><br><span class="line">                    self.currentRegion += <span class="number">1</span></span><br><span class="line">                    self.passedBy[x0,y0] = self.currentRegion</span><br><span class="line">                    self.stack.push((x0,y0))</span><br><span class="line">                    self.prev_region_count=<span class="number">0</span></span><br><span class="line">                    <span class="keyword">while</span> <span class="keyword">not</span> self.stack.isEmpty():</span><br><span class="line">                        x,y = self.stack.pop()</span><br><span class="line">                        self.BFS(x,y)</span><br><span class="line">                        self.iterations+=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span>(self.PassedAll()):</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">if</span>(self.prev_region_count&lt;<span class="number">8</span>*<span class="number">8</span>):</span><br><span class="line">                        self.passedBy[self.passedBy==self.currentRegion]=<span class="number">0</span></span><br><span class="line">                        x0=random.randint(x0<span class="number">-4</span>,x0+<span class="number">4</span>)</span><br><span class="line">                        y0=random.randint(y0<span class="number">-4</span>,y0+<span class="number">4</span>)</span><br><span class="line">                        x0=max(<span class="number">0</span>,x0)</span><br><span class="line">                        y0=max(<span class="number">0</span>,y0)</span><br><span class="line">                        x0=min(x0,self.h<span class="number">-1</span>)</span><br><span class="line">                        y0=min(y0,self.w<span class="number">-1</span>)</span><br><span class="line">                        self.currentRegion-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,self.h):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range (<span class="number">0</span>,self.w):</span><br><span class="line">                val = self.passedBy[i][j]</span><br><span class="line">                <span class="keyword">if</span>(val==<span class="number">0</span>):</span><br><span class="line">                    self.SEGS[i][j]=<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.SEGS[i][j]=val*<span class="number">35</span>,val*<span class="number">90</span>,val*<span class="number">30</span></span><br><span class="line">        <span class="keyword">if</span>(self.iterations&gt;<span class="number">200000</span>):</span><br><span class="line">            print(<span class="string">"Max Iterations"</span>)</span><br><span class="line">        print(<span class="string">"Iterations : "</span>+str(self.iterations))</span><br><span class="line">        cv2.imshow(<span class="string">""</span>,self.SEGS)</span><br><span class="line">        <span class="comment"># return self.SEGS</span></span><br><span class="line">        cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">        cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">BFS</span><span class="params">(self, x0,y0)</span>:</span></span><br><span class="line">        regionNum = self.passedBy[x0,y0]</span><br><span class="line">        elems=[]</span><br><span class="line">        elems.append((int(self.im[x0,y0,<span class="number">0</span>])+int(self.im[x0,y0,<span class="number">1</span>])+int(self.im[x0,y0,<span class="number">2</span>]))/<span class="number">3</span>)</span><br><span class="line">        var=self.thresh</span><br><span class="line">        neighbours=self.getNeighbour(x0,y0)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> neighbours:</span><br><span class="line">            <span class="keyword">if</span> self.passedBy[x,y] == <span class="number">0</span> <span class="keyword">and</span> self.distance(x,y,x0,y0)&lt;var:</span><br><span class="line">                <span class="keyword">if</span>(self.PassedAll()):</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                self.passedBy[x,y] = regionNum</span><br><span class="line">                self.stack.push((x,y))</span><br><span class="line">                elems.append((int(self.im[x,y,<span class="number">0</span>])+int(self.im[x,y,<span class="number">1</span>])+int(self.im[x,y,<span class="number">2</span>]))/<span class="number">3</span>)</span><br><span class="line">                var=np.var(elems)</span><br><span class="line">                self.prev_region_count+=<span class="number">1</span></span><br><span class="line">            var=max(var,self.thresh)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PassedAll</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.iterations&gt;<span class="number">200000</span> <span class="keyword">or</span> np.count_nonzero(self.passedBy &gt; <span class="number">0</span>) == self.w*self.h</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">limit</span><span class="params">(self, x,y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span>  <span class="number">0</span>&lt;=x&lt;self.h <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;self.w</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distance</span><span class="params">(self,x,y,x0,y0)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> ((int(self.im[x,y,<span class="number">0</span>])-int(self.im[x0,y0,<span class="number">0</span>]))**<span class="number">2</span>+(int(self.im[x,y,<span class="number">1</span>])-int(self.im[x0,y0,<span class="number">1</span>]))**<span class="number">2</span>+(int(self.im[x,y,<span class="number">2</span>])-int(self.im[x0,y0,<span class="number">2</span>]))**<span class="number">2</span>)**<span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">img = <span class="string">"./food.jpg"</span></span><br><span class="line">imgorin = cv2.imread(img,<span class="number">1</span>)</span><br><span class="line"><span class="comment"># imgorin = imgorin[:,:,[2,1,0]]  #show original in plt: cv2 is BGR, plt is RGB</span></span><br><span class="line">cv2.imshow(<span class="string">"original"</span>, imgorin)</span><br><span class="line">exemple = regionGrow(img,<span class="number">15</span>)</span><br><span class="line">exemple.ApplyRegionGrow()</span><br></pre></td></tr></table></figure><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/Screen%20Shot%202020-11-13%20at%2019.20.32.png" alt="Screen Shot 2020-11-13 at 19.20.32"></p><h2 id="区域分裂与合成算法"><a href="#区域分裂与合成算法" class="headerlink" title="区域分裂与合成算法"></a>区域分裂与合成算法</h2><p><strong>算法实现</strong></p><ul><li>对于图像中灰度级别不同的区域，均分为四个子区域</li><li>如果相邻的子区域所有像素的灰度级相同，则将其合并</li><li>反复进行上述两步操作，直至不再有新的分裂与合并为止</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> matplotlib.pyplot <span class="keyword">import</span> imread</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># calculate std of a cube of the image</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stdRight</span><span class="params">(h0, w0, h, w)</span>:</span></span><br><span class="line">    value = img[h0 : h0+h, w0: w0+w]</span><br><span class="line">    <span class="comment"># print(value)</span></span><br><span class="line">    cal_std = np.std(value, ddof=<span class="number">1</span>)</span><br><span class="line">    print(cal_std)</span><br><span class="line">    <span class="keyword">if</span> abs(cal_std) &lt; <span class="number">20</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thresholdFuc</span><span class="params">(h0, w0, h, w)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(w0, w0+w):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(h0, h0 + h):</span><br><span class="line">            <span class="keyword">if</span> img[j, i] &gt; <span class="number">127</span>:</span><br><span class="line">                img[j, i] = <span class="number">255</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                img[j, i] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># iteration for split when condition is true(condition is the std of a cube of img )</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iterationSplit</span><span class="params">(h0, w0, h, w)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> stdRight(h0, w0, h, w) <span class="keyword">and</span> min(h,w) &gt; <span class="number">5</span>:</span><br><span class="line">        iterationSplit(h0, w0, int(h / <span class="number">2</span>), int( w / <span class="number">2</span> ))</span><br><span class="line">        iterationSplit(h0 + int(h / <span class="number">2</span>), w0, int(h / <span class="number">2</span>), int( w / <span class="number">2</span> ))</span><br><span class="line">        iterationSplit(h0, w0 + int( w / <span class="number">2</span>), int(h / <span class="number">2</span>), int( w / <span class="number">2</span> ))</span><br><span class="line">        iterationSplit(h0 + int(h / <span class="number">2</span>), w0 + int( w / <span class="number">2</span>), int(h / <span class="number">2</span>), int( w / <span class="number">2</span> ))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        thresholdFuc(h0, w0, h, w)</span><br><span class="line">        <span class="comment"># ret, img[h0 : h, w0 : w]= cv2.threshold(img[h0:h, w0 : w], 50, 255, cv2.THRESH_BINARY)</span></span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">"./hy.jpg"</span>, <span class="number">0</span>)</span><br><span class="line">img_copy = img.copy()</span><br><span class="line">print(img.shape)</span><br><span class="line">h, w = img.shape</span><br><span class="line">iterationSplit(<span class="number">0</span>, <span class="number">0</span>, h, w)</span><br><span class="line"></span><br><span class="line"><span class="comment">#cv2.cvtColor() change BGR to RGB</span></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>), plt.imshow(cv2.cvtColor(img_copy, cv2.COLOR_BGR2RGB)), plt.title(<span class="string">"Original"</span>)</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>), plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB)), plt.title(<span class="string">"Result"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201113223633344.png" alt="image-20201113223633344"></p><p><em>Reference:</em></p><ul><li><a href="https://nirantak.com/image-processing-region-splitting#code" target="_blank" rel="noopener">https://nirantak.com/image-processing-region-splitting#code</a></li><li><a href="https://en.wikipedia.org/wiki/Split_and_merge_segmentation" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Split_and_merge_segmentation</a></li></ul><h2 id="分水岭分割算法"><a href="#分水岭分割算法" class="headerlink" title="分水岭分割算法"></a>分水岭分割算法</h2><h3 id="分割原理"><a href="#分割原理" class="headerlink" title="分割原理"></a>分割原理</h3><ul><li><p>任何的灰度级图像都可以被看作是一个地形图</p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201111163807118.png" alt="image-20201111163807118" style="zoom:50%;" /></li><li><p>假设从每个区域的最小值地方水位上涨，直至淹没整个地形，当处于不同的汇聚盆地的水将要汇聚到一起的时候，修剪大坝阻止聚合，最后得到水坝分界就是分水岭的分割线。</p></li><li><p>用1标记非对象（背景）的区域</p></li><li><p>用0标记不确定的区域</p></li><li><p>然后应用分水岭算法，用之前标记出的标签进行不断更新，标记对象的边界值为-1</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">watershedFuc</span><span class="params">(img)</span>:</span></span><br><span class="line">    <span class="comment">#threshold Otsu</span></span><br><span class="line">    gray = cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line">    ret, thresh = cv.threshold(gray,<span class="number">0</span>,<span class="number">255</span>,cv.THRESH_BINARY_INV+cv.THRESH_OTSU)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># noise removal</span></span><br><span class="line">    kernel = np.ones((<span class="number">3</span>,<span class="number">3</span>),np.uint8)</span><br><span class="line">    opening = cv.morphologyEx(thresh,cv.MORPH_OPEN,kernel, iterations = <span class="number">5</span>)</span><br><span class="line">    <span class="comment"># sure background area</span></span><br><span class="line">    sure_bg = cv.dilate(opening,kernel,iterations=<span class="number">5</span>)</span><br><span class="line">    <span class="comment"># Finding sure foreground area</span></span><br><span class="line">    dist_transform = cv.distanceTransform(opening,cv.DIST_L2, <span class="number">5</span>)</span><br><span class="line">    ret, sure_fg = cv.threshold(dist_transform,<span class="number">0.7</span>*dist_transform.max(),<span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># Finding unknown region</span></span><br><span class="line">    sure_fg = np.uint8(sure_fg)</span><br><span class="line">    unknown = cv.subtract(sure_bg,sure_fg)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Marker labelling</span></span><br><span class="line">    ret, markers = cv.connectedComponents(sure_fg)</span><br><span class="line">    <span class="comment"># Add one to all labels so that sure background is not 0, but 1</span></span><br><span class="line">    markers = markers+<span class="number">1</span></span><br><span class="line">    <span class="comment"># Now, mark the region of unknown with zero</span></span><br><span class="line">    markers[unknown==<span class="number">255</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Apply watershed</span></span><br><span class="line">    markers = cv.watershed(img,markers)</span><br><span class="line">    img[markers == <span class="number">-1</span>] = [<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    img1 = cv.imread(<span class="string">'./egg.jpg'</span>)</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>),plt.imshow(img1), plt.title(<span class="string">"eggOrin"</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">    img2 = cv.imread(<span class="string">'./coins.jpg'</span>)</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>),plt.imshow(img2), plt.title(<span class="string">"coinOrin"</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">    img = [img1, img2]</span><br><span class="line">    title = [<span class="string">"coinwatershed"</span>, <span class="string">'eggwatershed'</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        result = watershedFuc(img[i])</span><br><span class="line">        plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>**(i+<span class="number">1</span>)),plt.imshow(result), plt.title(title[i]), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p><strong>效果图</strong></p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201111164111409.png" alt="image-20201111164111409"></p><p><em>Reference：</em> <a href="https://docs.opencv.org/master/d3/db4/tutorial_py_watershed.html" target="_blank" rel="noopener">https://docs.opencv.org/master/d3/db4/tutorial_py_watershed.html</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>区域生长算法能够显示出具有相同特征的一些像素块，区分度较高，但是算法较为非时间，要确定好初始种子值和不再继续扩张的条件</li><li>区域分裂与合成算法，分块进行相同灰度级像素的合并和不同像素灰度级的分裂，直至不能再分裂为止，这里设定的不能分裂的条件使用的是方差，对于相差小的大块状的背景很容易在前几次分裂与合并中被直接去分开（例如，天空中的白云）进而直接被差值化</li><li>分水岭算法对于寻找边界非常明显，可以很好的找出目标对象的轮廓</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;区域生长算法，区域分裂与合成算法，分水岭分割算法&quot;&gt;&lt;a href=&quot;#区域生长算法，区域分裂与合成算法，分水岭分割算法&quot; class=&quot;headerlink&quot; title=&quot;区域生长算法，区域分裂与合成算法，分水岭分割算法&quot;&gt;&lt;/a&gt;区域生长算法，区域分裂与合成
      
    
    </summary>
    
    
    
      <category term="BuaaAssignments" scheme="https://github.com/liysky/liysky.github.io.git/tags/BuaaAssignments/"/>
    
  </entry>
  
  <entry>
    <title>不同阈值处理方法对于二值图像的影响</title>
    <link href="https://github.com/liysky/liysky.github.io.git/2020/11/10/threshouldeffecton2valueimg/"/>
    <id>https://github.com/liysky/liysky.github.io.git/2020/11/10/threshouldeffecton2valueimg/</id>
    <published>2020-11-10T04:22:00.000Z</published>
    <updated>2020-11-16T08:29:28.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="比较不同的阈值处理方法对生成二值图像的影响"><a href="#比较不同的阈值处理方法对生成二值图像的影响" class="headerlink" title="比较不同的阈值处理方法对生成二值图像的影响"></a>比较不同的阈值处理方法对生成二值图像的影响</h2><h3 id="全局阈值法"><a href="#全局阈值法" class="headerlink" title="全局阈值法"></a>全局阈值法</h3><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201109133450051.png" alt="image-20201109133450051"></p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201109133533603.png" alt="image-20201109133533603"></p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201109141042899.png" alt="image-20201109141042899"></p><p>opencv-python 中提供了cv.threshold 方法，可以设置将大于某一个阈值或者小于某一个阈值为临界，将其设置为0或者最大值。</p><p>第一个参数：原图像</p><p>第二个参数：阈值</p><p>第三个参数：最大值</p><p>第四个参数：阈值类型</p><p>即对于大于或者小于所设定的阈值进行的不同的处理方法类型</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201109150217758.png" alt="image-20201109150217758"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment">#read image</span></span><br><span class="line">img = cv2.imread(<span class="string">'./shot.jpg'</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">#thredholding with different type</span></span><br><span class="line">ret,thresh1 = cv2.threshold(img,<span class="number">50</span>,<span class="number">255</span>,cv2.THRESH_BINARY)</span><br><span class="line">ret,thresh2 = cv2.threshold(img,<span class="number">50</span>,<span class="number">255</span>,cv2.THRESH_BINARY_INV)</span><br><span class="line">ret,thresh3 = cv2.threshold(img,<span class="number">50</span>,<span class="number">255</span>,cv2.THRESH_TRUNC)</span><br><span class="line">ret,thresh4 = cv2.threshold(img,<span class="number">50</span>,<span class="number">255</span>,cv2.THRESH_TOZERO)</span><br><span class="line">ret,thresh5 = cv2.threshold(img,<span class="number">50</span>,<span class="number">255</span>,cv2.THRESH_TOZERO_INV)</span><br><span class="line">titles = [<span class="string">'Original Image'</span>,<span class="string">'BINARY'</span>,<span class="string">'BINARY_INV'</span>,<span class="string">'TRUNC'</span>,<span class="string">'TOZERO'</span>,<span class="string">'TOZERO_INV'</span>]</span><br><span class="line">images = [img, thresh1, thresh2, thresh3, thresh4, thresh5]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">3</span>,i+<span class="number">1</span>),plt.imshow(images[i],<span class="string">'gray'</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201109142140114.png" alt="image-20201109142140114"></p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201109154734991.png" alt="image-20201109154734991"></p><h3 id="自适应阈值化"><a href="#自适应阈值化" class="headerlink" title="自适应阈值化"></a>自适应阈值化</h3><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201109145358273.png" alt="image-20201109145358273"></p><p>使用统一的全局阈值法有缺陷在于，有的图像在不同的地方有不同的光照条件，在这种条件下，自适应阈值化能够提供帮助。</p><p>opencv-python 中提供了 cv.adptiveThreshold 方法</p><p>cv2.adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C[, dst])</p><p>其中，又提供了两种不同的阈值计算方法：</p><ul><li>cv.ADPTIVE_THRESH_MEAN_C: 阈值为邻域的平均值减去一个常数C</li><li>cv.ADPTIVE_THRESH_GASSIAN_C: 阈值为邻域高斯加权和减去一个常数C</li></ul><p><strong>blockSize：</strong> 决定邻域的大小</p><p><strong>C：</strong> 常数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'shot.jpg'</span>,<span class="number">0</span>)</span><br><span class="line">img = cv2.medianBlur(img,<span class="number">5</span>)<span class="comment">#</span></span><br><span class="line"></span><br><span class="line">ret,th1 = cv2.threshold(img,<span class="number">50</span>,<span class="number">255</span>,cv2.THRESH_BINARY)</span><br><span class="line">th2 = cv2.adaptiveThreshold(img,<span class="number">50</span>,cv2.ADAPTIVE_THRESH_MEAN_C,\</span><br><span class="line">            cv2.THRESH_BINARY,<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line">th3 = cv2.adaptiveThreshold(img,<span class="number">50</span>,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,\</span><br><span class="line">            cv2.THRESH_BINARY,<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">titles = [<span class="string">'Original Image'</span>, <span class="string">'Global Thresholding (v = 50)'</span>,</span><br><span class="line">            <span class="string">'Adaptive Mean Thresholding'</span>, <span class="string">'Adaptive Gaussian Thresholding'</span>]</span><br><span class="line">images = [img, th1, th2, th3]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">2</span>,i+<span class="number">1</span>),plt.imshow(images[i],<span class="string">'gray'</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201109143750177.png" alt="image-20201109143750177"></p><p><strong>相比较全局阈值方法，可以清晰的看到，自适应阈值化不会使得图像出现大面积的目标丢失——黑色块或者白色块，局部信息的细节更加友好，虽然不会出现大面积的目标丢失，但是对于最终目标的连结性是比较差的，通常包含有许多的噪点噪声，所以对于自适应的局部特性的自适应阈值方法，最后还会进行一些噪声去除的操作，从而消除噪声，来进一步加强对于目标物体的检测。</strong></p><h3 id="Otsu-大律阈值法"><a href="#Otsu-大律阈值法" class="headerlink" title="Otsu 大律阈值法"></a>Otsu 大律阈值法</h3><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201109164629903.png" alt="image-20201109164629903"></p><p>将图像按灰度阈值分为两类，分别求出两类的均值和方差，再求出两个类之间的方差，当类之间方差比类内方差最大时，所求出的阈值T，即为所求阈值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv.imread(<span class="string">'shot.jpg'</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># global thresholding</span></span><br><span class="line">ret1,th1 = cv.threshold(img,<span class="number">50</span>,<span class="number">255</span>,cv.THRESH_BINARY)</span><br><span class="line"><span class="comment"># Otsu's thresholding</span></span><br><span class="line">ret2,th2 = cv.threshold(img,<span class="number">0</span>,<span class="number">255</span>,cv.THRESH_BINARY+cv.THRESH_OTSU)</span><br><span class="line"><span class="comment"># plot all the images and their histograms</span></span><br><span class="line">images = [img, <span class="number">0</span>, th1,</span><br><span class="line">          img, <span class="number">0</span>, th2]</span><br><span class="line">titles = [<span class="string">'Original Noisy Image'</span>,<span class="string">'Histogram'</span>,<span class="string">'Global Thresholding (v=50)'</span>,</span><br><span class="line">          <span class="string">'Original Noisy Image'</span>,<span class="string">'Histogram'</span>,<span class="string">"Otsu's Thresholding"</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">    plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i*<span class="number">3</span>+<span class="number">1</span>),plt.imshow(images[i*<span class="number">3</span>],<span class="string">'gray'</span>)</span><br><span class="line">    plt.title(titles[i*<span class="number">3</span>]), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i*<span class="number">3</span>+<span class="number">2</span>),plt.hist(images[i*<span class="number">3</span>].ravel(),<span class="number">256</span>)</span><br><span class="line">    plt.title(titles[i*<span class="number">3</span>+<span class="number">1</span>]), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i*<span class="number">3</span>+<span class="number">3</span>),plt.imshow(images[i*<span class="number">3</span>+<span class="number">2</span>],<span class="string">'gray'</span>)</span><br><span class="line">    plt.title(titles[i*<span class="number">3</span>+<span class="number">2</span>]), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201109161123329.png" alt="image-20201109161123329"></p><p><strong>总结</strong></p><ul><li>全局阈值法处理的方法较自适应阈值法，两者的区别最主要集中在噪声分布和对于均匀光照还是非均匀光照的处理上，全局阈值法适合于简单单一的均匀光照条件上进行处理，而自适应阈值法适合于不同的局部光照条件，对于细节的处理会更好，但同时也会有噪声的保留。</li><li>大律法是一种更优的阈值处理方法，能够快速有效地找到类间的分割阈值，但是缺点在于对于目标的检测是单一的，如果想要检测的目标不属于同一或者接近的灰度区域，那么将会导致想要检测的目标物体的信息丢失，反映在图片上就是会有连结信息的消失（黑色块或者白色块），但是相较于普通的全局阈值处理，效果是由明显的提升对比的。</li></ul><table><thead><tr><th>全局阀值法</th><th>自适应阀值法</th><th>大津法</th></tr></thead><tbody><tr><td><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201109142140114.png" alt="image-20201109142140114"></td><td><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201109143750177.png" alt="image-20201109143750177"></td><td><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201110121940396.png" alt="image-20201110121940396"></td></tr></tbody></table><p><strong>Reference：</strong></p><p><a href="https://docs.opencv.org/master/d7/d4d/tutorial_py_thresholding.html" target="_blank" rel="noopener">https://docs.opencv.org/master/d7/d4d/tutorial_py_thresholding.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;比较不同的阈值处理方法对生成二值图像的影响&quot;&gt;&lt;a href=&quot;#比较不同的阈值处理方法对生成二值图像的影响&quot; class=&quot;headerlink&quot; title=&quot;比较不同的阈值处理方法对生成二值图像的影响&quot;&gt;&lt;/a&gt;比较不同的阈值处理方法对生成二值图像的影响&lt;/
      
    
    </summary>
    
    
    
      <category term="BuaaAssignments" scheme="https://github.com/liysky/liysky.github.io.git/tags/BuaaAssignments/"/>
    
  </entry>
  
  <entry>
    <title>频率域高通低通滤波&amp;同态滤波</title>
    <link href="https://github.com/liysky/liysky.github.io.git/2020/10/23/%E9%A2%91%E7%8E%87%E5%9F%9F%E9%AB%98%E9%80%9A%E4%BD%8E%E9%80%9A%E6%BB%A4%E6%B3%A2-%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/"/>
    <id>https://github.com/liysky/liysky.github.io.git/2020/10/23/%E9%A2%91%E7%8E%87%E5%9F%9F%E9%AB%98%E9%80%9A%E4%BD%8E%E9%80%9A%E6%BB%A4%E6%B3%A2-%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/</id>
    <published>2020-10-22T18:27:31.000Z</published>
    <updated>2020-10-31T08:07:32.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数字图像处理作业02"><a href="#数字图像处理作业02" class="headerlink" title="数字图像处理作业02"></a>数字图像处理作业02</h2><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h2 id="空间域与频率域"><a href="#空间域与频率域" class="headerlink" title="空间域与频率域"></a>空间域与频率域</h2><p><strong>空间域与频率域提供了观察图像的不同视角</strong></p><ul><li><p>空间域中，数字图像f(x,y)即为一个定义在二维空间中的矩形区域上的离散函数</p></li><li><p>如果将f(x,y)视为幅值变化（即空间域灰度值在平面空间的梯度——直观表现为衡量表征图像中灰度变化剧烈程度的指标）的二维信号——幅值变化即为灰度值的梯度。则可以通过某些变换手段（如傅立叶变换、离散余弦变化、小波变换等）在频域下对图像进行处理。</p></li><li><p>比如在空间图像里不好找出噪声的模式，如果变换到频率域，则比较好找出噪声的模式（高频分量），并能更容易处理。</p></li></ul><p><strong>空间域：</strong></p><p>有<strong>图像像素组成的空间</strong>，其<strong>物理描述的是图像的灰度 分布函数</strong>。</p><p><strong>频率域：</strong></p><p>以频率（即波数）为自变量的描述图像的特征，可以将一幅图像值元值在空间上的变化分解为具有不同振幅、空间频率和相位的简振函数的线性叠加，图像中各种频率成分的组成和分布称为空间频谱，<strong>其物理意义是图像的频率分布函数</strong>。这种对图像的频率特征进行分解、处理和分析称为频率域处理。</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201021140831977.png" alt="image-20201021140831977"></p><h2 id="频率域滤波的目的"><a href="#频率域滤波的目的" class="headerlink" title="频率域滤波的目的"></a>频率域滤波的目的</h2><ul><li>引起图像质量下降的噪声占频谱的高频段</li><li>图像边缘占高频段</li><li>图像主题或灰度缓变区域占低频段</li></ul><h2 id="在频率域研究图像的原因"><a href="#在频率域研究图像的原因" class="headerlink" title="在频率域研究图像的原因"></a>在频率域研究图像的原因</h2><ul><li>空间域复杂的问题转变为频谱上简单易于求解的问题</li><li>滤波在频率域更为直观，可以解释空间域滤波的某些性质</li><li>可以在频率域制定滤波器，做饭变换，然后在空间域使用结果滤波器作为空间域滤波器的指导</li></ul><h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><ul><li>利用傅立叶变换将原问题转变为频域上解决</li><li>应用反变换，将频域上的解转化为原问题的解</li></ul><h2 id="频率域的特征"><a href="#频率域的特征" class="headerlink" title="频率域的特征"></a>频率域的特征</h2><ul><li>频谱的直流低频分量对应图像的平滑区域</li><li>频谱的高频分量对应图像的边沿或变化剧烈区域</li><li>外界叠加噪声对应于频率较高的部分</li><li>恒定的干扰条纹对应频谱中的某些特征点</li></ul><h2 id="低通滤波"><a href="#低通滤波" class="headerlink" title="低通滤波"></a>低通滤波</h2><ul><li>构造一个低通滤波器，使得低频分量顺利通过，有效阻止高频分量</li><li>低通滤波时一个牺牲图像清晰度为代价来减少干扰效果的修饰过程</li><li>高通滤波与低通滤波作用相反，它使高频分量顺利通过，而削弱低通分量</li></ul><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201021145937937.png" alt="image-20201021145937937"></p><ul><li>低通滤波器类型<ul><li>理想低通滤波器：尖锐</li><li>巴特沃思低通滤波器：处于理想和高斯滤波器之间</li><li>高斯滤波器：平滑</li></ul></li></ul><h3 id="低通滤波器应用实例：模糊，平滑等"><a href="#低通滤波器应用实例：模糊，平滑等" class="headerlink" title="低通滤波器应用实例：模糊，平滑等"></a>低通滤波器应用实例：模糊，平滑等</h3><ul><li><p>字符识别：通过模拟图像，桥接断裂字符的裂缝</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201021151648193.png" alt="image-20201021151648193"></p></li><li><p>印刷和出版业：从一幅尖锐的原始图像产生平滑、柔和的外观，如减少人脸皮肤皱纹和小斑点</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201021151701682.png" alt="image-20201021151701682"></p></li><li><p>处理卫星和航空图像：尽可能模糊细节，保留大的可识别特征</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201021151718012.png" alt="image-20201021151718012"></p></li></ul><h3 id="频率域锐化滤波器"><a href="#频率域锐化滤波器" class="headerlink" title="频率域锐化滤波器"></a>频率域锐化滤波器</h3><p>图像的锐化可以通过高通滤波器过程实现，减弱傅立叶变换的低频成分，而不改变高频信息</p><p>是低通滤波的相反过程：</p><p>$H_{hp}(u,v) = 1-H_{lp}(u,v)$</p><h2 id="高通滤波器类型"><a href="#高通滤波器类型" class="headerlink" title="高通滤波器类型"></a>高通滤波器类型</h2><ul><li>理想高通滤波器：尖锐</li><li>巴特沃思高通滤波器：处于理想和高斯滤波器之间</li><li>高斯高通滤波器：平滑</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="comment">###################################################################</span></span><br><span class="line"><span class="comment">###############            进行频率域处理             #############</span></span><br><span class="line"><span class="comment">###################################################################</span></span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">"fog.jpg"</span>,<span class="number">0</span>)<span class="comment">#读图</span></span><br><span class="line">dft = cv2.dft(np.float64(img),flags = cv2.DFT_COMPLEX_OUTPUT)<span class="comment">#设置输入格式为float32</span></span><br><span class="line">dft_shift = np.fft.fftshift(dft)<span class="comment">#低频分量中心化处理，方便观察</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置振幅大小</span></span><br><span class="line">magnitude_spectrum = <span class="number">20</span> * np.log(cv2.magnitude(dft_shift[:, :, <span class="number">0</span>], dft_shift[:, :, <span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印输入图像</span></span><br><span class="line">plt.subplot(<span class="number">221</span>), plt.imshow(img, cmap=<span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">'input'</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取频谱图</span></span><br><span class="line">plt.subplot(<span class="number">222</span>), plt.imshow(magnitude_spectrum, cmap=<span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">'Frequency Domain'</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置低通滤波器</span></span><br><span class="line">rows, cols = img.shape</span><br><span class="line">crow,ccol = int(rows/<span class="number">2</span>), int(cols/<span class="number">2</span>) <span class="comment">#中心位置</span></span><br><span class="line">mask = np.zeros((rows, cols, <span class="number">2</span>), np.uint8)</span><br><span class="line">mask[crow<span class="number">-30</span>:crow+<span class="number">30</span>, ccol<span class="number">-30</span>:ccol+<span class="number">30</span>] = <span class="number">1</span><span class="comment">#设置矩形窗口遮罩，设为1，过滤高频</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#掩膜图像和频谱图像乘积</span></span><br><span class="line">f = dft_shift * mask</span><br><span class="line"></span><br><span class="line"><span class="comment">#傅里叶逆变换</span></span><br><span class="line">ishift = np.fft.ifftshift(f)</span><br><span class="line">iimg = cv2.idft(ishift)</span><br><span class="line">res = cv2.magnitude(iimg[:,:,<span class="number">0</span>], iimg[:,:,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示低通滤波处理图像</span></span><br><span class="line">plt.subplot(<span class="number">223</span>), plt.imshow(res, <span class="string">'gray'</span>), plt.title(<span class="string">'low'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = np.fft.fft2(img)</span><br><span class="line">fshift = np.fft.fftshift(f)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置高通滤波器</span></span><br><span class="line">rows, cols = img.shape</span><br><span class="line">crow,ccol = int(rows/<span class="number">2</span>), int(cols/<span class="number">2</span>)</span><br><span class="line">fshift[crow<span class="number">-30</span>:crow+<span class="number">30</span>, ccol<span class="number">-30</span>:ccol+<span class="number">30</span>] = <span class="number">0</span> <span class="comment">#设置矩形窗口遮罩，设为0，过滤低频</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#傅里叶逆变换</span></span><br><span class="line">ishift = np.fft.ifftshift(fshift)</span><br><span class="line">himg = np.fft.ifft2(ishift)</span><br><span class="line">himg = np.abs(himg)</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示原始图像和高通滤波处理图像</span></span><br><span class="line">plt.subplot(<span class="number">224</span>), plt.imshow(himg, <span class="string">'gray'</span>), plt.title(<span class="string">'high'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201023022624600.png" alt="image-20201023022624600"></p><h2 id="同态滤波"><a href="#同态滤波" class="headerlink" title="同态滤波"></a>同态滤波</h2><blockquote><p>  同态滤波是一种广泛于信号和图像处理的技术，将原本的信号经由非线性映射，转换到可以使用线性滤波器的不同域，做完运算后再映射回原始域。同态的性质就是保持相关的属性不变，而同态滤波的好处是将原本复杂的运算转为效能相同但相对简单的运算。这个概念在1960年代由Thomas Stockham，Alan V. Oppenheim和Ronald W. Schafer在麻省理工学院提出。——wiki</p></blockquote><p><strong>基本思想</strong></p><p>把图像的灰度函数 f(x,y) 看作为入射光分量和反射光分量两部分组成</p><p>$f(x,y) = i(x,y) r(x,y)$</p><p>i(x,y)：入射光，占据低频段</p><p>r(x,y)：反射光——取决于物体的特性，物体的亮度特征主要取决于反射光，占据高频段</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201021161436906.png" alt="image-20201021161436906"></p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201021155933953.png" alt="image-20201021155933953"></p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201021161549234.png" alt="image-20201021161549234"></p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201021161615446.png" alt="image-20201021161615446"></p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201021161632876.png" alt="image-20201021161632876"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">homomorphic_filter</span><span class="params">(src,d0 = <span class="number">1</span>,r1 = <span class="number">0.5</span>,rh=<span class="number">2</span>,c=<span class="number">4</span>,h=<span class="number">2.0</span>,l=<span class="number">0.5</span>)</span>:</span></span><br><span class="line">    gray = src.copy()      <span class="comment">#duplicate img</span></span><br><span class="line">    <span class="keyword">if</span> len(src.shape) &gt; <span class="number">2</span>:</span><br><span class="line">        gray = cv2.cvtColor(src,cv2.COLOR_BGR2GRAY) <span class="comment">#set image gray</span></span><br><span class="line">    gray = np.float64(gray)</span><br><span class="line">    print(gray)</span><br><span class="line">    rows,cols = gray.shape <span class="comment">#get rows and columns of inputed pic</span></span><br><span class="line"></span><br><span class="line">    gray_fft = np.fft.fft2(gray)    <span class="comment"># two dimension fft</span></span><br><span class="line">    print(gray_fft)</span><br><span class="line">    gray_fftshift = np.fft.fftshift(gray_fft)</span><br><span class="line">    print(gray_fftshift)</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    需要fftshift的原因：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    1、经过fft变换后，数据的频率范围是从[0,fs]排列的。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    2、而一般，我们在画图或者讨论的时候，是从[-fs/2,fs/2]的范围进行分析。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    3、因此，需要将经过fft变换后的图像的[fs/2,fs]部分移动到[-fs/2,0]这个范围内。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    而fftshift就是完成这个功能。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    通常，如果想得到所见的中间是0频的图像，经过fft变换后，都要再经过fftshift。</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    dst_fftshift = np.zeros_like(gray_fftshift) <span class="comment">#产生0类似的零矩阵</span></span><br><span class="line">    <span class="comment"># np.meshgrid: 矩阵化   np.arange: start,stop,step 'arange can solve remainder'</span></span><br><span class="line">    M,N = np.meshgrid(np.arange(-cols // <span class="number">2</span>,cols // <span class="number">2</span>),np.arange(-rows//<span class="number">2</span>,rows//<span class="number">2</span>))</span><br><span class="line">    D = np.sqrt(M ** <span class="number">2</span> + N ** <span class="number">2</span>) <span class="comment">#square result</span></span><br><span class="line">    Z = (rh - r1) * (<span class="number">1</span> - np.exp(-c * (D ** <span class="number">2</span> / d0 ** <span class="number">2</span>))) + r1</span><br><span class="line"></span><br><span class="line">    <span class="comment">#使用频率增强函数进行对原频域的分量进行处理</span></span><br><span class="line">    dst_fftshift = Z * gray_fftshift                <span class="comment">#对零矩阵进行Z处理，Z*原频域处理后的分量</span></span><br><span class="line">    dst_fftshift = (h - l) * dst_fftshift + l</span><br><span class="line"></span><br><span class="line">    dst_ifftshift = np.fft.ifftshift(dst_fftshift)</span><br><span class="line">    dst_ifft = np.fft.ifft2(dst_ifftshift)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#取实数部分</span></span><br><span class="line">    dst = np.real(dst_ifft)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#np.clip to clip bigger than 255</span></span><br><span class="line">    dst = np.uint8(np.clip(dst,<span class="number">0</span>,<span class="number">255</span>))</span><br><span class="line">    <span class="keyword">return</span> dst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># main</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#resize img</span></span><br><span class="line">    img = cv2.imread(<span class="string">"preSny.jpg"</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">    img = cv2.resize(img, (<span class="number">600</span>,<span class="number">400</span>))</span><br><span class="line"></span><br><span class="line">    img_new = homomorphic_filter(img)</span><br><span class="line">    result = np.hstack((img, img_new))</span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">"Contrast"</span>, result)</span><br><span class="line"></span><br><span class="line">    cv2.waitKey()</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201023012547066.png" alt="image-20201023012547066"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数字图像处理作业02&quot;&gt;&lt;a href=&quot;#数字图像处理作业02&quot; class=&quot;headerlink&quot; title=&quot;数字图像处理作业02&quot;&gt;&lt;/a&gt;数字图像处理作业02&lt;/h2&gt;&lt;h2 id=&quot;背景知识&quot;&gt;&lt;a href=&quot;#背景知识&quot; class=&quot;head
      
    
    </summary>
    
    
    
      <category term="BuaaAssignments" scheme="https://github.com/liysky/liysky.github.io.git/tags/BuaaAssignments/"/>
    
  </entry>
  
  <entry>
    <title>数字图像处理work-空间域/图像域-直方图均衡化/平滑空间滤波/锐化滤波器</title>
    <link href="https://github.com/liysky/liysky.github.io.git/2020/10/19/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86work-%E7%A9%BA%E9%97%B4%E5%9F%9F-%E5%9B%BE%E5%83%8F%E5%9F%9F-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96-%E5%B9%B3%E6%BB%91%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2-%E9%94%90%E5%8C%96%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
    <id>https://github.com/liysky/liysky.github.io.git/2020/10/19/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86work-%E7%A9%BA%E9%97%B4%E5%9F%9F-%E5%9B%BE%E5%83%8F%E5%9F%9F-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96-%E5%B9%B3%E6%BB%91%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2-%E9%94%90%E5%8C%96%E6%BB%A4%E6%B3%A2%E5%99%A8/</id>
    <published>2020-10-19T09:17:58.000Z</published>
    <updated>2020-10-19T09:20:28.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数字图像处理作业01"><a href="#数字图像处理作业01" class="headerlink" title="数字图像处理作业01"></a>数字图像处理作业01</h2><h3 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h3><p>直方图均衡化是将原图像通过某种变化，得到一幅灰度直方图为均匀分布的新图像的方法。</p><p>这种方法通常用来增加许多图像的全局对比度。增强局部亮度的对比对而不影响整体的对比度。</p><p><strong>实现</strong></p><p>离散的灰度图像{x}，其中$$n_i$$ 表示灰度i出现的次数，有：</p><p>$$p_x(i) = p(x = i ) = \frac{n_i}{n}$$</p><p>关于灰度i的概率密度函数</p><p>相应对 $p_x$ 的累积分布函数，有：</p><p>$f_x(i) = \sum_{j=0}^{i}P_x(j)$</p><p>再创建一个形式为 $y=T(x)$ 的变换，对于原始图像中每个值产生一个y</p><p>最后将进行值的映射和变换：</p><p>$y’ = y(max{x}-min{x}) + min{x}$</p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201015133327561.png" alt="image-20201015133327561" style="zoom:33%;" /><p>应用：</p><ul><li>对于背景和前景太亮或者太暗的图像非常有用。</li><li>例如对X光图像中更好地显示骨骼结构的曝光或曝光不足处理</li></ul><p><em>代码</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#read image</span></span><br><span class="line">img = cv2.imread(<span class="string">"preSny.jpg"</span>, <span class="number">1</span>)</span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">cv2.imshow(<span class="string">"src"</span>, gray)</span><br><span class="line"></span><br><span class="line"><span class="comment">#call opencv-python histogram function: equalizeHist()</span></span><br><span class="line">dst = cv2.equalizeHist(gray)</span><br><span class="line"><span class="comment">#show image</span></span><br><span class="line">cv2.imshow(<span class="string">"dst"</span>, dst)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destoryAllWindows()</span><br></pre></td></tr></table></figure><h3 id="平滑空间滤波器"><a href="#平滑空间滤波器" class="headerlink" title="平滑空间滤波器"></a>平滑空间滤波器</h3><p>作用：主要用于去除图像中一些不重要的细节。</p><p>分类：</p><ul><li>线性滤波器：均值滤波器</li><li>非线性滤波器<ul><li>最大值滤波器</li><li>中值滤波器</li><li>最小值滤波器</li></ul></li></ul><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201015144348111.png" alt="image-20201015144348111" style="zoom: 33%;" /><p><strong>均值滤波器</strong></p><p>均值滤波器属于线性滤波器，有：</p><ul><li>减小图像灰度的“尖锐”变化</li><li>减小噪声</li><li>但由于图像边缘是图像灰度尖锐变化引起的，所以存在<strong>边缘模糊问题</strong></li></ul><p><strong>中值滤波器</strong></p><p>非线性滤波器</p><p>基于滤波器所在图像区域中像素的排序，由排序结果决定的值代替中心像素的值</p><p>中值滤波器：用像素领域内中间值代替该像素（寻找像素周围内的中间值）</p><p>主要计算公式：</p><p>$R = mid{Z_k| k = 1,2,…n}$</p><p><strong>主要用途：去除噪声</strong></p><p>算法的特点</p><ul><li>去除噪声的同时，比较好的保留边的锐度和图像的细节（优于均值滤波器）</li><li>能够有效去除脉冲噪声：以黑白点叠加在图像上</li></ul><p><em>代码</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#source image and resize image</span></span><br><span class="line">img00 = cv2.imread(<span class="string">"demoShot.png"</span>,<span class="number">1</span>)</span><br><span class="line">scale_percent = <span class="number">45</span></span><br><span class="line">img_width = int(img00.shape[<span class="number">1</span>]*scale_percent / <span class="number">100</span>)</span><br><span class="line">img_height = int(img00.shape[<span class="number">0</span>]*scale_percent / <span class="number">100</span>)</span><br><span class="line">dsize = (img_width, img_height)</span><br><span class="line">img00 = cv2.resize(img00, dsize)</span><br><span class="line"></span><br><span class="line"><span class="comment">#medianBlur and Blur</span></span><br><span class="line">img_medianBlur = cv2.medianBlur(img00, <span class="number">7</span>)</span><br><span class="line">img_Blur = cv2.blur(img00,(<span class="number">7</span>,<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#cv2.imshow("image", np.hstack((img00,img_medianBlur,img_Blur)) )</span></span><br><span class="line">cv2.imshow(<span class="string">"originShot"</span>, img00)</span><br><span class="line">cv2.imshow(<span class="string">"medianBlur"</span>, img_medianBlur)</span><br><span class="line">cv2.imshow(<span class="string">"Blur"</span>, img_Blur)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h3 id="锐化滤波器"><a href="#锐化滤波器" class="headerlink" title="锐化滤波器"></a>锐化滤波器</h3><p>主要作用：</p><ul><li><p>突出图像中的细节，增强被模糊的细节</p></li><li><p>印刷中的层次强调，弥补扫描钝化</p></li><li><p>超声探测成像，针对于分辨率低的图片</p></li><li><p>图像识别中的边缘提取</p></li><li><p>回复过度钝化，曝光不足的图像</p></li><li><p>尖锐目标识别</p></li></ul><p>采用的是用微分的方式进行锐化，有一阶微分滤波器和二阶微分滤波器</p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201015143033332.png" alt="image-20201015143033332" style="zoom: 33%;" /><p><strong>梯度算子——一阶微分滤波器</strong></p><p>边缘检测不是非常明显，边缘检测产生的噪声比较多</p><p><strong>拉普拉斯算子——二阶微分滤波器</strong></p><p>主要保留目标轮廓的锐化效果，边缘轮廓显示十分明显，适合于进行目标物体边缘检测</p><p><em>代码</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">"apple.png"</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">img = cv2.resize(img, (<span class="number">300</span>,<span class="number">400</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># img = cv2.GaussianBlur(img, (3, 3), 0)</span></span><br><span class="line"><span class="comment"># img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#cv2.sobel derivative</span></span><br><span class="line">sobel_x = cv2.Sobel(img,cv2.CV_64F, <span class="number">1</span>, <span class="number">0</span>, ksize = <span class="number">5</span>)</span><br><span class="line">sobel_y = cv2.Sobel(img,cv2.CV_64F, <span class="number">0</span>, <span class="number">1</span>, ksize = <span class="number">5</span>)</span><br><span class="line"><span class="comment">#converting back to uint8</span></span><br><span class="line">sobel_x = cv2.convertScaleAbs(sobel_x)</span><br><span class="line">sobel_y = cv2.convertScaleAbs(sobel_y)</span><br><span class="line">sobel_xy = cv2.addWeighted(sobel_x, <span class="number">0.5</span>, sobel_y, <span class="number">0.5</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#cv2.scharr derivative</span></span><br><span class="line">scharr_x = cv2.Scharr(img, cv2.CV_64F, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">scharr_y = cv2.Scharr(img, cv2.CV_64F, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">scharr_x = cv2.convertScaleAbs(scharr_x)</span><br><span class="line">scharr_y = cv2.convertScaleAbs(scharr_y)</span><br><span class="line">scharr_xy = cv2.addWeighted(scharr_x, <span class="number">0.5</span>, scharr_y, <span class="number">0.5</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#apply laplace</span></span><br><span class="line">laplacian = cv2.Laplacian(img,cv2.CV_64F)</span><br><span class="line">laplacian = cv2.convertScaleAbs(laplacian)</span><br><span class="line"></span><br><span class="line"><span class="comment">#show result</span></span><br><span class="line">cv2.imshow(<span class="string">"origin"</span>, img)</span><br><span class="line">cv2.imshow(<span class="string">"sobel"</span>, sobel_xy)</span><br><span class="line"><span class="comment">#cv2.imshow("scharr", scharr_xy)</span></span><br><span class="line">cv2.imshow(<span class="string">"laplacian"</span>, laplacian)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数字图像处理作业01&quot;&gt;&lt;a href=&quot;#数字图像处理作业01&quot; class=&quot;headerlink&quot; title=&quot;数字图像处理作业01&quot;&gt;&lt;/a&gt;数字图像处理作业01&lt;/h2&gt;&lt;h3 id=&quot;直方图均衡化&quot;&gt;&lt;a href=&quot;#直方图均衡化&quot; class=&quot;
      
    
    </summary>
    
    
    
      <category term="BuaaAssignments" scheme="https://github.com/liysky/liysky.github.io.git/tags/BuaaAssignments/"/>
    
  </entry>
  
  <entry>
    <title>笔记- GAMES101计算机图形学入门-闫令琪</title>
    <link href="https://github.com/liysky/liysky.github.io.git/2020/10/09/%E7%AC%94%E8%AE%B0-GAMES101%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA/"/>
    <id>https://github.com/liysky/liysky.github.io.git/2020/10/09/%E7%AC%94%E8%AE%B0-GAMES101%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA/</id>
    <published>2020-10-09T15:22:19.000Z</published>
    <updated>2020-10-10T19:28:25.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="笔记-GAMES101计算机图形学入门-闫令琪"><a href="#笔记-GAMES101计算机图形学入门-闫令琪" class="headerlink" title="笔记- GAMES101计算机图形学入门-闫令琪"></a>笔记- GAMES101计算机图形学入门-闫令琪</h1><h2 id="P1-Overview-of-Computer-Graphic"><a href="#P1-Overview-of-Computer-Graphic" class="headerlink" title="P1 Overview of Computer Graphic"></a>P1 Overview of Computer Graphic</h2><ul><li><p>什么是好的画面：亮</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201009192116202.png" alt="image-20201009192116202"></p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201009192142797.png" alt="image-20201009192142797"></p></li></ul><p><strong>课程主要内容</strong></p><ul><li>Resterization 光栅化</li><li>Curves and Meshes 曲线和曲面（几何）</li><li>Ray Tracing 光线追踪</li><li>Animation / Simulation 动画和模拟</li></ul><h3 id="Rasterization-光栅化"><a href="#Rasterization-光栅化" class="headerlink" title="Rasterization 光栅化"></a>Rasterization 光栅化</h3><p>理解：将三位形态的几何形体显示在屏幕上</p><ul><li>Project geometry primitive (3D triangle / polygons) onto the screen</li><li>Break projected primitives into fragments (pixels)</li><li>Gold standard in Video Games (Real-time Applications)</li></ul><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201009225239197.png" alt="image-20201009225239197"></p><h3 id="Curves-and-Meshes"><a href="#Curves-and-Meshes" class="headerlink" title="Curves and Meshes"></a>Curves and Meshes</h3><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201009225422283.png" alt="image-20201009225422283"></p><h3 id="Ray-Tracing"><a href="#Ray-Tracing" class="headerlink" title="Ray Tracing"></a>Ray Tracing</h3><ul><li>Shoot rays from the camera though each pixel<ul><li>calculate intersection and shading</li><li>continue to bounce the rays till the hit light sources </li></ul></li><li>Gold standard in Animations / Movies (Offline Applications)</li></ul><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201009225708474.png" alt="image-20201009225708474"></p><h3 id="Animation-Simulation"><a href="#Animation-Simulation" class="headerlink" title="Animation / Simulation"></a>Animation / Simulation</h3><ul><li>Key frame Animation</li><li>Mass-spring System</li></ul><h3 id="CG-is-NOT-CV"><a href="#CG-is-NOT-CV" class="headerlink" title="CG is NOT CV"></a>CG is NOT CV</h3><p>计算机图形学不是计算机视觉</p><ul><li><p>计算机视觉是进行图像的识别，比如：识别人</p><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/image-20201009230345629.png" alt="image-20201009230345629"></p></li></ul><h3 id="Use-An-IDE"><a href="#Use-An-IDE" class="headerlink" title="Use An IDE"></a>Use An IDE</h3><ul><li>hints syntax </li><li>function</li></ul><p><strong>Recommended IDEs</strong></p><ul><li>Visual Studio / Visual Studio Code</li><li>Qt Creator</li></ul><h2 id="P2-Review-of-Linear-Algebra"><a href="#P2-Review-of-Linear-Algebra" class="headerlink" title="P2 Review of Linear Algebra"></a>P2 Review of Linear Algebra</h2><p><strong>Graphics’s Dependencies</strong></p><ul><li>Basic mathematics<ul><li>Linear algebra, calculus, statistics</li></ul></li><li>Basic physics<ul><li>Optics, Mechanics</li></ul></li><li>Misc<ul><li>Signal processing</li><li>Numerical analysis</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;笔记-GAMES101计算机图形学入门-闫令琪&quot;&gt;&lt;a href=&quot;#笔记-GAMES101计算机图形学入门-闫令琪&quot; class=&quot;headerlink&quot; title=&quot;笔记- GAMES101计算机图形学入门-闫令琪&quot;&gt;&lt;/a&gt;笔记- GAMES101计算机图
      
    
    </summary>
    
    
    
      <category term="learning-note" scheme="https://github.com/liysky/liysky.github.io.git/tags/learning-note/"/>
    
  </entry>
  
  <entry>
    <title>std::vector in c++</title>
    <link href="https://github.com/liysky/liysky.github.io.git/2020/09/23/std-vector-in-c/"/>
    <id>https://github.com/liysky/liysky.github.io.git/2020/09/23/std-vector-in-c/</id>
    <published>2020-09-23T15:57:49.000Z</published>
    <updated>2020-10-09T15:24:48.426Z</updated>
    
    <content type="html"><![CDATA[<p>std::vector in C++</p><p><strong>Declaration of std::vector</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; marks;</span><br></pre></td></tr></table></figure><p><strong>initialization of std::vector</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; marks = &#123;<span class="number">50</span>, <span class="number">45</span>, <span class="number">47</span>, <span class="number">65</span>, <span class="number">80</span>&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; marks;</span><br><span class="line">marks = &#123;<span class="number">50</span>, <span class="number">45</span>, <span class="number">47</span>, <span class="number">65</span>, <span class="number">80</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>Length of std::vector</strong></p><p>marks.size() — <strong>function</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; marks = &#123;<span class="number">50</span>, <span class="number">45</span>, <span class="number">47</span>, <span class="number">65</span>, <span class="number">80</span>&#125;;</span><br><span class="line">    marks = &#123;<span class="number">50</span>, <span class="number">47</span>, <span class="number">60</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"length of array : "</span> &lt;&lt; marks.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Pass a std::vector to function</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">( <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v )</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"v["</span> &lt;&lt; i &lt;&lt; <span class="string">"] = "</span> &lt;&lt; v[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//        v[2] = 4;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, World!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    printVector(v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>noted from: <a href="https://www.codesdope.com/cpp-stdvector/" target="_blank" rel="noopener">https://www.codesdope.com/cpp-stdvector/</a></p><blockquote><p>  <strong>void printVector(const std::vector&lt;int&gt; &amp;n) - const is used here to prevent the compiler from making a copy of the vector and this enhances the performance. The passed vector will be n in this function as &amp;n is the parameter of the function ‘printArray’.</strong></p></blockquote><p><img src="https://jaximage-1253102271.cos.ap-beijing.myqcloud.com/uPic/Screen%20Shot%202020-09-23%20at%2023.11.10.png" alt="Screen Shot 2020-09-23 at 23.11.10"></p><p><strong>front &amp; back</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//usage of front;</span></span><br><span class="line">marks.front();</span><br><span class="line"><span class="comment">//usage of back;</span></span><br><span class="line">marks.back();</span><br></pre></td></tr></table></figure><p><strong>empty</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">marks.empty() <span class="comment">//if true, return 1; else return 0;</span></span><br></pre></td></tr></table></figure><p><strong>resize</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1 = &#123;<span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    v1.resize(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>() ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v1[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">6</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>assign</strong></p><p>assigns new contents to the vector and replaces its current contents all.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.assign(<span class="number">7</span>, <span class="number">40</span>);  <span class="comment">// 7 elements each of value 40</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>push_back</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    v.push_back(<span class="number">47</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printing values of v</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"elements of v"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>pop_back</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    v.pop_back();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printing values of v</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"elements of v"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>reserve</strong></p><p>This function increases the capacity of the vector if the desired number of elements is greater than the capacity of the vector.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v1.push_back(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v1.reserve(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity : "</span> &lt;&lt; v1.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">capacity:100</span><br></pre></td></tr></table></figure><p><strong>erase</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1 = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    v1.erase(v1.<span class="built_in">begin</span>()+<span class="number">4</span>);  <span class="comment">// removing a single element at position 4</span></span><br><span class="line">    v2.erase(v2.<span class="built_in">begin</span>()+<span class="number">1</span>, v2.<span class="built_in">begin</span>()+<span class="number">3</span>);   <span class="comment">// removing range of elements from position 1 till 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//printing the values of v1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Values of v1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v1[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printing the values of v2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Values of v2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v2.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v2[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Values of v1</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line">Values of v2</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>clear</strong></p><p>clear all elements of the vector.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2 = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    v1.swap(v2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Vector v1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: v1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Vector v2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: v2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Multidimensional std::vector</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;  v &#123;&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; v[i][j] &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span></span><br><span class="line"><span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span></span><br></pre></td></tr></table></figure><p><strong>Passing a multidimensional std::vector to a function</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;v[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; v[i][j] &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;  v &#123;&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;&#125;&#125;;</span><br><span class="line">    <span class="built_in">display</span>(v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;std::vector in C++&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Declaration of std::vector&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="https://github.com/liysky/liysky.github.io.git/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 7.Reverse Integer</title>
    <link href="https://github.com/liysky/liysky.github.io.git/2020/09/22/Reverse-Integer/"/>
    <id>https://github.com/liysky/liysky.github.io.git/2020/09/22/Reverse-Integer/</id>
    <published>2020-09-22T14:29:14.000Z</published>
    <updated>2020-10-09T15:39:32.543Z</updated>
    
    <content type="html"><![CDATA[<p> <a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">7. Reverse Integer</a></p><p>Given a 32-bit signed integer, reverse digits of an integer.</p><p><strong>Example 1:</strong></p><p>Input: 123<br>Output: 321<br><strong>Example 2:</strong></p><p>Input: -123<br>Output: -321<br><strong>Example 3:</strong></p><p>Input: 120<br>Output: 21<br>Note:<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">           x /= <span class="number">10</span>;</span><br><span class="line">           <span class="keyword">if</span>(ans &gt; INT_MAX / <span class="number">10</span> || ans == INT_MAX / <span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">if</span>(ans &lt; INT_MIN / <span class="number">10</span> || ans == INT_MIN / <span class="number">10</span> &amp;&amp; pop &lt; <span class="number">-8</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           ans = ans * <span class="number">10</span> + pop;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Explanation：</strong></p><blockquote><p>  #define INT_MAX = 2147483647</p><p>  #define INT_MAX = -INT_MAX-1</p></blockquote><p>也就是关于int的最大值和最小值的说明</p><p>将一个数字进行反转，从个位数进行取，使用取余的方法，再使用“余数X10”进行往高位移动。</p><p>这个过程中需要注意溢出时的条件即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/reverse-integer/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;7. Reverse Integer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Given a 32-bit 
      
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="https://github.com/liysky/liysky.github.io.git/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode4. Median of Two Sorted Arrays</title>
    <link href="https://github.com/liysky/liysky.github.io.git/2020/03/10/LeetCode4-Median-of-Two-Sorted-Arrays/"/>
    <id>https://github.com/liysky/liysky.github.io.git/2020/03/10/LeetCode4-Median-of-Two-Sorted-Arrays/</id>
    <published>2020-03-10T15:09:06.000Z</published>
    <updated>2020-05-05T15:36:19.398Z</updated>
    
    <content type="html"><![CDATA[<h3 id="4-Median-of-Two-Sorted-Arrays"><a href="#4-Median-of-Two-Sorted-Arrays" class="headerlink" title="4. Median of Two Sorted Arrays"></a>4. Median of Two Sorted Arrays</h3><p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. Median of Two Sorted Arrays</a></p><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p>You may assume nums1 and nums2 cannot be both empty.</p><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><p>nums1 = [1, 3]<br>nums2 = [2]</p><p>The median is 2.0<br>Example 2:</p><p>nums1 = [1, 2]<br>nums2 = [3, 4]</p><p>The median is (2 + 3)/2 = 2.5</p><h3 id="solution-1"><a href="#solution-1" class="headerlink" title="solution 1"></a>solution 1</h3><p>merge array1 and array2, then return the median.</p><p><strong>Time complexity: O(m+n)</strong></p><p><strong>Space complexity: O( m+n )</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[m+n];</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> (nums2[n/<span class="number">2</span> - <span class="number">1</span>] + nums2[n/<span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[n/<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> (nums1[m/<span class="number">2</span> -<span class="number">1</span>] + nums1[m/<span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[m/<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count != (m+n))&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == m)&#123;</span><br><span class="line">                <span class="keyword">while</span>( j != n)&#123;</span><br><span class="line">                    nums[count++] = nums2[j++];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == n)&#123;</span><br><span class="line">                <span class="keyword">while</span>(i != m)&#123;</span><br><span class="line">                    nums[count++] = nums1[i++];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">                nums[count++] = nums1[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[count++] = nums2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count %<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (nums[count/<span class="number">2</span> - <span class="number">1</span>] + nums[count/<span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[count/<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;4-Median-of-Two-Sorted-Arrays&quot;&gt;&lt;a href=&quot;#4-Median-of-Two-Sorted-Arrays&quot; class=&quot;headerlink&quot; title=&quot;4. Median of Two Sorted Arrays&quot;&gt;&lt;/
      
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="https://github.com/liysky/liysky.github.io.git/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode628. Maximum Product of Three Numbers</title>
    <link href="https://github.com/liysky/liysky.github.io.git/2020/03/07/LeetCode628-Maximum-Product-of-Three-Numbers/"/>
    <id>https://github.com/liysky/liysky.github.io.git/2020/03/07/LeetCode628-Maximum-Product-of-Three-Numbers/</id>
    <published>2020-03-07T14:48:27.000Z</published>
    <updated>2020-05-05T15:36:19.402Z</updated>
    
    <content type="html"><![CDATA[<h3 id="628-Maximum-Product-of-Three-Numbers"><a href="#628-Maximum-Product-of-Three-Numbers" class="headerlink" title="628. Maximum Product of Three Numbers"></a>628. Maximum Product of Three Numbers</h3><p><a href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers/" target="_blank" rel="noopener">628. Maximum Product of Three Numbers</a></p><p>Given an integer array, find three numbers whose product is maximum and output the maximum product.</p><p>Example 1:</p><p>Input: [1,2,3]<br>Output: 6</p><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h3><p>Input: [1,2,3,4]<br>Output: 24</p><h3 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h3><p>The length of the given array will be in range [3,104] and all elements are in the range [-1000, 1000].<br>Multiplication of any three numbers in the input won’t exceed the range of 32-bit signed integer.</p><h3 id="Solution-one"><a href="#Solution-one" class="headerlink" title="Solution one"></a>Solution one</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>] * nums[<span class="number">1</span>] * nums[nums.length-<span class="number">1</span>], nums[nums.length-<span class="number">1</span>]* nums[nums.length-<span class="number">2</span>] * nums[nums.length-<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Solution 1</strong></p><p>Most important key of solution is that the negative situation may be contained in array.</p><p>return two miximum * one maximum compared to three maximum.</p><p><strong>Time complexity: O(nlogn)</strong></p><p><strong>Space complexity: O(0)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c++</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>] * nums[<span class="number">1</span>] * nums[n<span class="number">-1</span>], nums[n<span class="number">-1</span>] * nums[n - <span class="number">2</span>] * nums[n - <span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>sort( begin( ), end( ) );</li><li>sort( rbegin( ), rend( ) );</li></ul><h3 id="solution-2"><a href="#solution-2" class="headerlink" title="solution 2"></a>solution 2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max1 = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> max2 = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> max3 = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> min1 = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> min2 = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &gt; max1)&#123;</span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = max1;</span><br><span class="line">                max1 = num;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &gt; max2)&#123;</span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = num;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &gt; max3)&#123;</span><br><span class="line">                max3 = num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &lt; min1)&#123;</span><br><span class="line">                min2 = min1;</span><br><span class="line">                min1 = num;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &lt; min2)&#123;</span><br><span class="line">                min2 = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max( max1 * min1 * min2, max1 * max2 * max3 );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>note:</strong> In C++, max is INT_MAX, min is INT_MIN</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;628-Maximum-Product-of-Three-Numbers&quot;&gt;&lt;a href=&quot;#628-Maximum-Product-of-Three-Numbers&quot; class=&quot;headerlink&quot; title=&quot;628. Maximum Product
      
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="https://github.com/liysky/liysky.github.io.git/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode637. Average of Levels in Binary Tree</title>
    <link href="https://github.com/liysky/liysky.github.io.git/2020/03/04/LeetCode637-Average-of-Levels-in-Binary-Tree/"/>
    <id>https://github.com/liysky/liysky.github.io.git/2020/03/04/LeetCode637-Average-of-Levels-in-Binary-Tree/</id>
    <published>2020-03-04T12:46:13.000Z</published>
    <updated>2020-05-05T15:36:19.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="637-Average-of-Levels-in-Binary-Tree"><a href="#637-Average-of-Levels-in-Binary-Tree" class="headerlink" title="637. Average of Levels in Binary Tree"></a>637. Average of Levels in Binary Tree</h3><p><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/" target="_blank" rel="noopener">637. Average of Levels in Binary Tree</a></p><p>Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.</p><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><p>Input:<br>    3<br>   / <br>  9  20<br>    /  <br>   15   7<br>Output: [3, 14.5, 11]</p><h3 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation:"></a>Explanation:</h3><p>The average value of nodes on level 0 is 3,  on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].<br>Note:</p><p>The range of node’s value is in the range of 32-bit signed integer.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DFS Solution.</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt;&gt; sum_count;</span><br><span class="line">        preorder(root, <span class="number">0</span>, sum_count);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : sum_count)&#123;</span><br><span class="line">            ans.push_back( <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(p.first)/p.second );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">( TreeNode* root, <span class="keyword">int</span> depth,  <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt;&gt;&amp; sum_count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(depth &gt;= sum_count.<span class="built_in">size</span>()) sum_count.push_back(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        sum_count[depth].first += root-&gt;val;</span><br><span class="line">        ++sum_count[depth].second;</span><br><span class="line">        preorder(root-&gt;left, depth+<span class="number">1</span>, sum_count);</span><br><span class="line">        preorder(root-&gt;right, depth+<span class="number">1</span>, sum_count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>note：pair using &amp; explain</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CPP program to illustrate pair STL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pair &lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; PAIR1 ;</span><br><span class="line"></span><br><span class="line">    PAIR1.first = <span class="number">100</span>;</span><br><span class="line">    PAIR1.second = <span class="string">'G'</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; PAIR1.first &lt;&lt; <span class="string">" "</span> ; <span class="comment">//visit the first value;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; PAIR1.second &lt;&lt; <span class="built_in">endl</span> ; <span class="comment">//visit the second value;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//out:</span></span><br><span class="line"><span class="comment">//100G</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//standard initializtion</span></span><br><span class="line">pair &lt;data_type1, data_type2&gt; pair_name(value1, value2);</span><br><span class="line"><span class="comment">//initialization can be also omitted</span></span><br><span class="line">pair &lt;data_type1, data_type2&gt; pair_name;</span><br></pre></td></tr></table></figure><p><strong>Time Complexity: O(N) , N is the nodes number of Tree</strong></p><p><strong>Space Complexity: O(H) , H is the height of Tree</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BFS Solution.</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ans;</span><br><span class="line">      <span class="built_in">vector</span>&lt;TreeNode*&gt; curr, next;</span><br><span class="line">      curr.push_back(root);</span><br><span class="line">      <span class="keyword">while</span>(!curr.empty())&#123;<span class="comment">//when curr point is null, it means all over.</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">const</span> <span class="keyword">auto</span>&amp; node : curr )&#123;</span><br><span class="line">          sum += node-&gt;val;</span><br><span class="line">          <span class="keyword">if</span>(node-&gt;left) next.push_back(node-&gt;left);</span><br><span class="line">          <span class="keyword">if</span>(node-&gt;right) next.push_back(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push_back(<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(sum)/curr.<span class="built_in">size</span>());</span><br><span class="line">        curr.swap(next);<span class="comment">//swap curr with next</span></span><br><span class="line">        next.<span class="built_in">clear</span>();</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Time Complexity: O(N) , N is the nodes number of Tree</strong></p><p><strong>Space Complexity: O(M) , M is the maximum  of every level to the Tree</strong></p><p>Solution version using Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java</span></span><br><span class="line"><span class="comment"> * DFS</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Double&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Double&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; count = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        getSumOfLevel(root, <span class="number">0</span>, ans, count);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++)&#123;</span><br><span class="line">            ans.set(i, ans.get(i)/count.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getSumOfLevel</span><span class="params">(TreeNode t, <span class="keyword">int</span> depth, List &lt; Double &gt; ans, List &lt; Integer &gt; count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(depth &lt; ans.size())&#123;</span><br><span class="line">            ans.set(depth, ans.get(depth)+t.val);</span><br><span class="line">            count.set(depth, count.get(depth)+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans.add(t.val*<span class="number">1.0</span>);</span><br><span class="line">            count.add(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        getSumOfLevel(t.left, depth+<span class="number">1</span>, ans, count);</span><br><span class="line">        getSumOfLevel(t.right, depth+<span class="number">1</span>, ans, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java BFS</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Double&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Double&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            Queue&lt;TreeNode&gt; temp = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">                TreeNode t = queue.remove();</span><br><span class="line">                sum += t.val;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(t.left != <span class="keyword">null</span> )&#123;</span><br><span class="line">                    temp.add(t.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t.right != <span class="keyword">null</span> )&#123;</span><br><span class="line">                    temp.add(t.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queue = temp;</span><br><span class="line">            ans.add(((<span class="keyword">double</span>)sum)/count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;637-Average-of-Levels-in-Binary-Tree&quot;&gt;&lt;a href=&quot;#637-Average-of-Levels-in-Binary-Tree&quot; class=&quot;headerlink&quot; title=&quot;637. Average of Leve
      
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="https://github.com/liysky/liysky.github.io.git/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode463. Island Perimeter</title>
    <link href="https://github.com/liysky/liysky.github.io.git/2020/03/02/LeetCode463-Island-Perimeter/"/>
    <id>https://github.com/liysky/liysky.github.io.git/2020/03/02/LeetCode463-Island-Perimeter/</id>
    <published>2020-03-01T17:05:38.000Z</published>
    <updated>2020-05-05T15:36:19.340Z</updated>
    
    <content type="html"><![CDATA[<h3 id="463-Island-Perimeter"><a href="#463-Island-Perimeter" class="headerlink" title="463. Island Perimeter"></a>463. Island Perimeter</h3><p><a href="https://leetcode-cn.com/problems/island-perimeter/" target="_blank" rel="noopener">463. Island Perimeter</a></p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water.</p><p>Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).</p><p>The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island. </p><h3 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h3><p>Input:<br>[[0,1,0,0],<br> [1,1,1,0],<br> [0,1,0,0],<br> [1,1,0,0]]</p><p>Output: 16</p><p>Explanation: The perimeter is the 16 yellow stripes in the image below:</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcex6vvgn3j306505xwe9.jpg" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.empty())    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> area = <span class="number">0</span>, nei = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; m; ++y)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; n; ++x)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[y][x] == <span class="number">1</span>)&#123;</span><br><span class="line">                    area++;</span><br><span class="line">                    <span class="keyword">if</span>(y &gt; <span class="number">0</span> &amp;&amp;grid[y<span class="number">-1</span>][x] == <span class="number">1</span> )  nei++;</span><br><span class="line">                    <span class="keyword">if</span>(y &lt; m<span class="number">-1</span> &amp;&amp; grid[y+<span class="number">1</span>][x] == <span class="number">1</span>) nei++;</span><br><span class="line">                    <span class="keyword">if</span>(x &gt; <span class="number">0</span> &amp;&amp; grid[y][x<span class="number">-1</span>]==<span class="number">1</span>) nei++;</span><br><span class="line">                    <span class="keyword">if</span>(x &lt; n<span class="number">-1</span>&amp;&amp; grid[y][x+<span class="number">1</span>] == <span class="number">1</span>) nei++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area*<span class="number">4</span> - nei;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Time Complexity: O(m*n)</strong></p><p><strong>Space Complexity: O(1)</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;463-Island-Perimeter&quot;&gt;&lt;a href=&quot;#463-Island-Perimeter&quot; class=&quot;headerlink&quot; title=&quot;463. Island Perimeter&quot;&gt;&lt;/a&gt;463. Island Perimeter&lt;/h3
      
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="https://github.com/liysky/liysky.github.io.git/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>最小数组</title>
    <link href="https://github.com/liysky/liysky.github.io.git/2020/03/01/%E6%9C%80%E5%B0%8F%E6%95%B0%E7%BB%84/"/>
    <id>https://github.com/liysky/liysky.github.io.git/2020/03/01/%E6%9C%80%E5%B0%8F%E6%95%B0%E7%BB%84/</id>
    <published>2020-03-01T15:53:39.000Z</published>
    <updated>2020-05-05T15:36:19.386Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>第一行输入一个数n，1 &lt;= n &lt;= 1000，下面输入n行数据，每一行有两个数，分别是x y。输出一组x y，该组数据是所有数据中x最小，且在x相等的情况下y最小的。</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入有多组数据。</span><br><span class="line">每组输入n，然后输入n个整数对。</span><br></pre></td></tr></table></figure><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出最小的整数对。</span><br></pre></td></tr></table></figure><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">3 3</span><br><span class="line">2 2</span><br><span class="line">5 5</span><br><span class="line">2 1</span><br><span class="line">3 6</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  <span class="keyword">int</span> m, n, x, y;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num)!=EOF)&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;<span class="comment">//提前输入第一组数据，然后在进行比较</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num; i++)&#123;</span><br><span class="line">      <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">      <span class="keyword">if</span>(x&lt;m||x==m&amp;&amp;y&lt;n)&#123;</span><br><span class="line">        m = x;</span><br><span class="line">        n = y;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m&lt;&lt;<span class="string">" "</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>整体思路：只保留最小的一组数据</strong></p><p><strong>#include&lt;bits/stdc++.h&gt; 几乎包含了所有C++ 的头文件</strong></p><p>C++常规解法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pair</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Pair a,Pair b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x&gt;b.x)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//返回升序排序</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.x==b.x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.y&lt;b.y)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//若x相同时，按y升序</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//否则还是按x升序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//按x降序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">        Pair *p=<span class="keyword">new</span> Pair[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">        sort(p,p+n,cmp);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p[<span class="number">0</span>].x&lt;&lt;<span class="string">" "</span>&lt;&lt;p[<span class="number">0</span>].y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关于C++ 的sort函数的使用</strong></p><p>参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">RandomIt</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">sort</span>( <span class="title">RandomIt</span> <span class="title">first</span>, <span class="title">RandomIt</span> <span class="title">last</span> );</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">RandomIt</span>, <span class="title">class</span> <span class="title">Compare</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">sort</span>( <span class="title">RandomIt</span> <span class="title">first</span>, <span class="title">RandomIt</span> <span class="title">last</span>, <span class="title">Compare</span> <span class="title">comp</span> );</span></span><br></pre></td></tr></table></figure><p>形式：sort(first_pointer,first_pointer+n,cmp)</p><p>其中cmp可以省略，如果省略则默认按照升序排序</p><p>且 <strong>cmp</strong> 函数可以重载</p><ul><li>可在结构体内部重载</li><li>也可在结构体外部进行重载</li></ul><p>cmp基本用法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a &gt; b;<span class="comment">//即返回降序排序</span></span><br><span class="line">  <span class="comment">//return a &lt; b；//返回升序排序</span></span><br><span class="line">    <span class="comment">//----&gt; 其上都是根据字面排序literally</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cmp结构体排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student stu[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Student a, Student b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.x &gt; b.x; <span class="comment">//literally sort by a.x</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;第一行输入一个数n，1 &amp;lt;= n &amp;lt;= 1000，下面输入n行数据，每一行有两个数，分别是x y。输出一组x y
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>比较奇偶个数</title>
    <link href="https://github.com/liysky/liysky.github.io.git/2020/03/01/%E6%AF%94%E8%BE%83%E5%A5%87%E5%81%B6%E4%B8%AA%E6%95%B0/"/>
    <id>https://github.com/liysky/liysky.github.io.git/2020/03/01/%E6%AF%94%E8%BE%83%E5%A5%87%E5%81%B6%E4%B8%AA%E6%95%B0/</id>
    <published>2020-03-01T15:20:01.000Z</published>
    <updated>2020-05-05T15:36:19.364Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>第一行输入一个数，为n，第二行输入n个数，这n个数中，如果偶数比奇数多，输出NO，否则输出YES。</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入有多组数据。</span><br><span class="line">每组输入n，然后输入n个整数（1&lt;&#x3D;n&lt;&#x3D;1000）。</span><br></pre></td></tr></table></figure><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果偶数比奇数多，输出NO，否则输出YES。</span><br></pre></td></tr></table></figure><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 5 2 4 3</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>复制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;<span class="comment">//奇数的个数(净个数)</span></span><br><span class="line">    <span class="keyword">int</span> n, x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            <span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">1</span>) count++;</span><br><span class="line">            <span class="keyword">else</span> count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count&lt;<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>第一个while 保证了多次测试，只要输入合法就一直在循环判断中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;第一行输入一个数，为n，第二行输入n个数，这n个数中，如果偶数比奇数多，输出NO，否则输出YES。&lt;/p&gt;
&lt;h3 id=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
